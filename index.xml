<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Enzyme AD</title><link>https://enzyme.mit.edu/</link><description>Recent content on Enzyme AD</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://enzyme.mit.edu/index.xml" rel="self" type="application/rss+xml"/><item><title>Using Enzyme</title><link>https://enzyme.mit.edu/getting_started/UsingEnzyme/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/UsingEnzyme/</guid><description>Generating LLVM To begin, let&amp;rsquo;s create a simple code test.c we want to differentiate. Enzyme will replace any calls to functions whose names contain &amp;ldquo;__enzyme_autodiff&amp;rdquo; with calls to the corresponding For now, let&amp;rsquo;s ignore the details of Enzyme&amp;rsquo;s calling convention/ABI which are described in detail here // test.c #include &amp;lt;stdio.h&amp;gt;extern double __enzyme_autodiff(void*, double); double square(double x) { return x * x; } double dsquare(double x) { // This returns the derivative of square or 2 * x return __enzyme_autodiff((void*) square, x); } int main() { for(double i=1; i&amp;lt;5; i++) printf(&amp;#34;square(%f)=%f, dsquare(%f)=%f&amp;#34;, i, square(i), i, dsquare(i)); } We can generate LLVM from this code by calling clang as follows.</description></item><item><title>Presentations</title><link>https://enzyme.mit.edu/talks/Talks/</link><pubDate>Wed, 29 Mar 2023 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/talks/Talks/</guid><description>Tech Talks Supercomputing (SC) 2022, Scalable Automatic Differentiation of Multiple Parallel Paradigms through Compiler Augmentation ; William S. Moses, Sri Hari Krishna Narayanan, Ludger Paehler, Valentin Churavy, Jan Hueckelheim, Michel Schanen, Johannes Doerfert, and Paul Hovland; video 2nd MODE Workshop on Differentiable Programming for Experiment Design 2022, Synthesization of Fast Gradients with Enzyme ; William S. Moses, Ludger Paehler, Tim Gymnich, and Valentin Churavy; slides ICPP Workshop on LLVM in Parallel Processing (LLPP) 2022, Enzyme: Automatic Differentiation of Parallel Programs ; William S.</description></item><item><title>Related Publications</title><link>https://enzyme.mit.edu/talks/Publications/</link><pubDate>Wed, 29 Mar 2023 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/talks/Publications/</guid><description>Papers SC 22, Scalable Automatic Differentiation of Multiple Parallel Paradigms through Compiler Augmentation ; William S. Moses, Sri Hari Krishna Narayanan, Ludger Paehler, Valentin Churavy, Michel Schanen, Jan Hueckelheim, Johannes Doerfert, and Paul Hovland. Best Student Paper SC 21, Reverse-Mode Automatic Differentiation and Optimization of GPU Kernels via Enzyme ; William S. Moses, Valentin Churavy, Ludger Paehler, Jan HÃ¼ckelheim, Sri Hari Krishna Narayanan, Michel Schanen, and Johannes Doerfert. NeurIPS 2020, Instead of Rewriting Foreign Code for Machine Learning, Automatically Synthesize Fast Gradients ; William S.</description></item><item><title>Calling Convention</title><link>https://enzyme.mit.edu/getting_started/CallingConvention/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/CallingConvention/</guid><description>Enzyme is invoked by calling a function __enzyme_autodiff with the function being differentiated, followed by the corresponding primal and shadow arguments. This will result in the original function being run with the corresponding derivative values being computed.
Function Hooks Enzyme replaces all calls to functions that contain the string __enzyme_autodiff with a call to the corresponding derivative. This is done to allow Enzyme to register multiple function signatures.
#include &amp;lt;stdio.h&amp;gt;template&amp;lt;typename T&amp;gt; T square(T x) { return x * x; } float __enzyme_autodiffFloat(float (*)(float), float); double __enzyme_autodiffDouble(double (*)(double), double); int main() { printf(&amp;#34;float d/dx %f\n&amp;#34;, __enzyme_autodiffFloat(square&amp;lt;float&amp;gt;, 1.</description></item><item><title>C++ Examples</title><link>https://enzyme.mit.edu/getting_started/Examples/</link><pubDate>Tue, 25 Jul 2023 00:00:00 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/Examples/</guid><description>There are many ways to implement a given calculation. This document contains examples of how to apply Enzyme to different kinds of patterns that show up frequently in C++. To make the code snippets below more concise, we&amp;rsquo;ll assume that each example snippet has the following definitions prepended to the translation unit:
int enzyme_dup; int enzyme_dupnoneed; int enzyme_out; int enzyme_const; template &amp;lt; typename return_type, typename ... T &amp;gt; extern return_type __enzyme_fwddiff(void*, T .</description></item><item><title>Enzyme Conference 2023</title><link>https://enzyme.mit.edu/talks/EnzymeCon/</link><pubDate>Wed, 29 Mar 2023 15:26:15 +0000</pubDate><guid>https://enzyme.mit.edu/talks/EnzymeCon/</guid><description>About The first Enzyme workshop took place from February 22-24 in Boulder, Co. The workshop&amp;rsquo;s aim was to bring together the contributors and users of Enzyme in particular, and people interested in automatic differentiation within the LLVM infrastructure in general, for two days of fast-paced high-bandwidth idea exchange and collaboration bootstrapping. For this the workshop was designed to have a flexible format, friendly to practitioners and researchers alike; its program consisted of a mix of presentations, tutorials, roundtable discussions and live programming sessions.</description></item><item><title>CUDA Guide</title><link>https://enzyme.mit.edu/getting_started/CUDAGuide/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/CUDAGuide/</guid><description>Reference C++ example WARNING: CUDA support is highly experimental and in active development.
Suppose we wanted to port the following C++ code to CUDA, with Enzyme autodiff support:
#include &amp;lt;stdio.h&amp;gt; void foo(double* x_in, double *x_out) { x_out[0] = x_in[0] * x_in[0]; } int enzyme_dup; int enzyme_out; int enzyme_const; typedef void (*f_ptr)(double*, double*); extern void __enzyme_autodiff(f_ptr, int, double*, double*, int, double*, double*); int main() { double x = 1.4; double d_x = 0.</description></item><item><title>FAQ</title><link>https://enzyme.mit.edu/getting_started/Faq/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://enzyme.mit.edu/getting_started/Faq/</guid><description>Enzyme builds successfully but won&amp;rsquo;t run tests Double check that Enzyme&amp;rsquo;s build can find lit, LLVM&amp;rsquo;s testing framework. This can be done by explicitly passing lit as an argument to CMake as described here .
Enzyme is Crashing LLVM&amp;rsquo;s plugin infrastructure is broken in many versions. Empirically LLVM 8 and up will often incorrectly disallow memory from being passed between LLVM and a plugin. If you see one of these errors and want to use the same version of LLVM try passing the flag enzyme_preopt=0 described here .</description></item></channel></rss>