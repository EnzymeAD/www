<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>C++ Examples - Enzyme AD</title><meta name=description content="Enzyme Automatic Differentiation Framework"><meta name=generator content="Hugo 0.74.3"><link href=https://enzyme.mit.edu/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://enzyme.mit.edu/getting_started/Examples/><link rel=stylesheet href=https://enzyme.mit.edu/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://enzyme.mit.edu/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://enzyme.mit.edu/js/bundle.js></script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><a href=/ style=text-decoration:none;color:#000><img src=https://enzyme.mit.edu//logo.svg width=40px align=absmiddle>
Enzyme AD</a></div></h1><p class=description>Enzyme Automatic Differentiation Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://groups.google.com/d/forum/enzyme-dev>Discussion List</a></li></ul></li><li><a href=https://github.com/EnzymeAD/Enzyme>GitHub</a></li><li><a href=https://github.com/wsmoses/Enzyme/issues>Bugs</a></li><li><a href=/explorer>Try Online</a></li><li><a href=/conference>Conference</a></li><li><a href=/getting_started/Faq/>FAQ</a></li></ul></nav></div><div class=content-container><main><h1>C++ Examples</h1><p>There are many ways to implement a given calculation. This document contains examples of how to apply Enzyme to different kinds of patterns that show up frequently in C++. To make the code snippets below more concise, we&rsquo;ll assume that each example snippet has the following definitions prepended to the translation unit:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>int</span> <span class=n>enzyme_dup</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>enzyme_dupnoneed</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>enzyme_out</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>enzyme_const</span><span class=p>;</span>

<span class=k>template</span> <span class=o>&lt;</span> <span class=k>typename</span> <span class=n>return_type</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span> <span class=n>T</span> <span class=o>&gt;</span>
<span class=n>return_type</span> <span class=n>__enzyme_fwddiff</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>T</span> <span class=p>...</span> <span class=p>);</span>

<span class=k>template</span> <span class=o>&lt;</span> <span class=k>typename</span> <span class=n>return_type</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span> <span class=n>T</span> <span class=o>&gt;</span>
<span class=n>return_type</span> <span class=n>__enzyme_autodiff</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>T</span> <span class=p>...</span> <span class=p>);</span>
</code></pre></div><h2 id=free-functions-return-by-value>Free Functions: Return-By-Value&nbsp;<a class=headline-hash href=#free-functions-return-by-value>¶</a></h2><p>Consider a function with one scalar input and one scalar output, \(f(x) \coloneqq x^2.\) We can implement this in C++ as a free function:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>The derivative of this function is simply \(f&rsquo;(x) = 2x\), but rather than implement that by hand, let&rsquo;s see how do it with automatically with Enzyme:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>5.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dx</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>df_dx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x) = %f, f&#39;(x) = %f&#34;</span><span class=p>,</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>df_dx</span><span class=p>);</span>
<span class=c1>// prints f(x) = 25.000000, f&#39;(x) = 10.000000
</span></code></pre></div><p>The first argument tells enzyme which function we want to differentiate, and the subsequent
arguments describe where to evaluate the derivatve and in what &ldquo;direction&rdquo;.</p><p>Link to example: <a href=https://fwd.gymni.ch/Hx6hwt>https://fwd.gymni.ch/Hx6hwt</a></p><hr><p>Next, we&rsquo;ll look at a function with two inputs and one output,
$$
f(x, y) \coloneqq x \, y + \frac{1}{y}
$$</p><p>The &ldquo;derivative&rdquo; (i.e. the Jacobian) of this function is a row vector with two entries:
$$
\bold{J} = \left[
\begin{array}{cc}
\displaystyle \frac{\partial f}{\partial x} & \displaystyle \frac{\partial f}{\partial y}
\end{array}
\right]
$$
There are two fundamental operations that involve the Jacobian:</p><ol><li>&ldquo;forward mode&rdquo; differentiation: compute \(df := \bold{J} \cdot d\bold{x}\), (where \(d\bold{x} = [dx \,\, dy]^\top\))</li><li>&ldquo;reverse mode&rdquo; differentiation: compute \(\boldsymbol{\mu} := \bold{J}^\top \lambda\)</li></ol><p>There&rsquo;s lots more to say here about when to use forward mode or reverse mode, but that&rsquo;s beyond the scope of this document, so we&rsquo;ll just focus on how to use Enzyme to perform these two kinds of differentiation for us.</p><p>Like before, start by implementing the original function</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><h4 id=forward-mode>Forward Mode&nbsp;<a class=headline-hash href=#forward-mode>¶</a></h4><p><code>__enzyme_fwddiff</code> implements forward-mode differentiation, and we use it by specifying where to evaluate \(\bold{J}\), and what values to use for \(d\bold{x}\)</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>3.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dx</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dy</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>df</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x) = %f, df = %f&#34;</span><span class=p>,</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>),</span> <span class=n>df</span><span class=p>)</span>
<span class=c1>// prints f(x) = 6.500000, df = 4.750000
</span></code></pre></div><blockquote><p>But what if I only want to (forward) differentiate with respect to some of the inputs?</p></blockquote><p>There are two approaches:</p><ol><li><p>Set <code>dx</code> or <code>dy</code> to zeroes as needed for unwanted derivatives</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>);</span> 
<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdx = %f, dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdx</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdx = 2.000000, dfdy = 2.750000
</span></code></pre></div></li><li><p>Specify <code>enzyme_const</code> to indicate which arguments are not to be differentiated</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span> 
<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdx = %f, dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdx</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdx = 2.000000, dfdy = 2.750000
</span></code></pre></div></li></ol><p>Option 1 has the benefit of flexibility&ndash; we can choose to turn differentiation with respect to certain variables on or off at runtime. Option 2 hard codes which derivatives can be computed, which narrows scope and potentially improves performance. The appropriate choice will depend on the specific needs of your project.</p><p>Link to example: <a href=https://fwd.gymni.ch/OJMdAx>https://fwd.gymni.ch/OJMdAx</a></p><h4 id=reverse-mode>Reverse Mode&nbsp;<a class=headline-hash href=#reverse-mode>¶</a></h4><p><code>__enzyme_autodiff</code> implements reverse-mode differentiation. We tell enzyme which function to differentiate, and pass information about where to evaluate the Jacobian. The <code>enzyme_out</code> specifier indicates which components (i.e. rows of the vector-jacobian product \(\bold{J}^\top \lambda\)) we want</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>double2</span><span class=p>{</span> <span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span> <span class=p>};</span>

<span class=p>...</span>

<span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>3.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=k>auto</span> <span class=p>[</span><span class=n>mu_x</span><span class=p>,</span> <span class=n>mu_y</span><span class=p>]</span> <span class=o>=</span> <span class=n>__enzyme_autodiff</span><span class=o>&lt;</span><span class=n>double2</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;mu_x = %f, mu_y = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>mu_x</span><span class=p>,</span> <span class=n>mu_y</span><span class=p>);</span>
<span class=c1>// prints mu_x = 2.000000, mu_y = 2.750000
</span></code></pre></div><p>The value returned by <code>__enzyme_autodiff</code> is the concatenation of the different <code>enzyme_out</code> quantities. Here, we define a struct, <code>double2</code> to represent those output values (and use C++17 structured binding to split them into <code>mu_x, mu_y</code>).</p><blockquote><p>Note: it may be tempting to store the outputs in a <code>std::tuple&lt; double, double ></code>, but the memory layout of <code>std::tuple</code> is implementation defined (e.g. some compilers implement <code>std::tuple&lt;T, U, V></code> with <code>V</code> first, <code>U</code> second, and <code>T</code> last). So, please don&rsquo;t store the outputs of <code>__enzyme_autodiff</code> in a <code>std::tuple</code>!</p></blockquote><p>Link to example: <a href=https://fwd.gymni.ch/HMFTsY>https://fwd.gymni.ch/HMFTsY</a></p><h2 id=free-functions-return-by-reference>Free Functions: Return-By-Reference&nbsp;<a class=headline-hash href=#free-functions-return-by-reference>¶</a></h2><p>Another possible way to implement the previous function is with an out-parameter:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>,</span> <span class=kt>double</span> <span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span> <span class=p>{</span> <span class=n>output</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>Differentiating functions like this with enzyme is similar to the return-by-value case, but with some small differences.</p><p>If we only care about the derivative output, and not the function value itself, we can use the <code>enzyme_dupnoneed</code> descriptor. This lets the compiler optimize away unnecessary calculations associated with evaluating the output.</p><h4 id=forward-mode-1>Forward Mode&nbsp;<a class=headline-hash href=#forward-mode-1>¶</a></h4><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// these will be overwritten by __enzyme_fwddiff
</span><span class=c1></span><span class=kt>double</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dz</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=cp>#if 1
</span><span class=cp></span><span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> 
                                 <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>,</span> 
                                 <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dz</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x,y) = %f, df = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>dz</span><span class=p>);</span>
<span class=c1>// prints f(x,y) = 6.500000, df = 7.500000
</span><span class=c1></span><span class=cp>#else
</span><span class=cp></span><span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> 
                                 <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>,</span> 
                                 <span class=n>enzyme_dupnoneed</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dz</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x,y) = %f, df = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>dz</span><span class=p>);</span>
<span class=c1>// prints f(x,y) = 0.000000, df = 7.500000
</span><span class=c1></span><span class=cp>#endif
</span></code></pre></div><p>Note: the by-reference arguments of the function are passed to <code>__enzyme_fwddiff</code> by address.</p><p>Link to example: <a href=https://fwd.gymni.ch/BtpzAA>https://fwd.gymni.ch/BtpzAA</a></p><h4 id=reverse-mode-1>Reverse Mode&nbsp;<a class=headline-hash href=#reverse-mode-1>¶</a></h4><p>vector-Jacobian product \(\boldsymbol{\mu} := \bold{J}^\top \lambda\) is implemented as</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// lambda is an input to __enzyme_autodiff 
</span><span class=c1></span><span class=kt>double</span> <span class=n>lambda</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=cp>#if 1
</span><span class=cp></span><span class=n>double2</span> <span class=n>mu</span> <span class=o>=</span> <span class=n>__enzyme_autodiff</span><span class=o>&lt;</span><span class=n>double2</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> 
                                                  <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> 
                                                  <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;z = %f, mu.x = %f, mu.y = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
<span class=c1>// prints z = 6.500000, mu.x = 4.000000, mu.y = 5.500000
</span><span class=c1></span><span class=cp>#else
</span><span class=cp></span><span class=n>double2</span> <span class=n>mu</span> <span class=o>=</span> <span class=n>__enzyme_autodiff</span><span class=o>&lt;</span><span class=n>double2</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> 
                                                  <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> 
                                                  <span class=n>enzyme_dupnoneed</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;z = %f, mu.x = %f, mu.y = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
<span class=c1>// prints z = 0.000000, mu.x = 4.000000, mu.y = 5.500000
</span><span class=c1></span><span class=cp>#endif
</span></code></pre></div><p>Link to example: <a href=https://fwd.gymni.ch/eYmIzw>https://fwd.gymni.ch/eYmIzw</a></p><h3 id=function-templates>Function Templates&nbsp;<a class=headline-hash href=#function-templates>¶</a></h3><p>Function templates are treated much the same way as regular functions, except
we need to explicitly include the template arguments when passing the function to
enzyme. For example, if we had the following definition:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>template</span> <span class=o>&lt;</span> <span class=k>typename</span> <span class=n>T</span> <span class=o>&gt;</span>
<span class=kt>void</span> <span class=n>f</span><span class=p>(</span><span class=n>T</span> <span class=n>x</span><span class=p>,</span> <span class=n>T</span> <span class=n>y</span><span class=p>,</span> <span class=n>T</span> <span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span> <span class=p>{</span> <span class=n>output</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>Then the first argument looks like</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> 
                                         <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>,</span> 
                                         <span class=n>enzyme_dupnoneed</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dz</span><span class=p>);</span>
</code></pre></div><p>Link to example: <a href=https://fwd.gymni.ch/WJVVRt>https://fwd.gymni.ch/WJVVRt</a></p><h2 id=member-functions>Member Functions&nbsp;<a class=headline-hash href=#member-functions>¶</a></h2><p>Differentiating member functions with Enzyme is a little bit trickier, since a member
function in C++ is effectively a function with an implicitly passed argument (the <code>this</code> pointer).
This means that if we have an object with a member function</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>MyObject</span> <span class=p>{</span>
    <span class=kt>double</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
    <span class=kt>double</span> <span class=n>x</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div><p>we can&rsquo;t pass <code>&MyObject::f</code> directly to <code>__enzyme_fwddiff(...)</code>. Instead, what
we can do is write a free function that calls the desired member function:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=nf>wrapper</span><span class=p>(</span><span class=n>MyObject</span> <span class=n>obj</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>f</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>and pass <em>that</em> to enzyme:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>wrapper</span><span class=p>,</span> <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> 
                                                       <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdy = 5.500000
</span></code></pre></div><blockquote><p>Note: if the member function belongs to a class or struct with no member variables,
it may be optimized away at the call site, which disrupts the argument ordering and
leads to an error. See: <a href=https://github.com/EnzymeAD/Enzyme/issues/1388#issuecomment-1728114457>https://github.com/EnzymeAD/Enzyme/issues/1388#issuecomment-1728114457</a> for more information on a workaround.</p></blockquote><p>A more general implementation of the wrapper function (that works with
different objects and argument types) is given below:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>template</span> <span class=o>&lt;</span> <span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span> <span class=n>arg_types</span> <span class=o>&gt;</span>
<span class=k>auto</span> <span class=n>wrapper</span><span class=p>(</span><span class=n>T</span> <span class=n>obj</span><span class=p>,</span> <span class=n>arg_types</span> <span class=o>&amp;&amp;</span> <span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>obj</span><span class=p>.</span><span class=n>f</span><span class=p>(</span><span class=n>args</span> <span class=p>...</span> <span class=p>);</span>
<span class=p>}</span>

<span class=p>...</span>

<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>wrapper</span><span class=o>&lt;</span><span class=n>MyObject</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span><span class=p>,</span> 
        <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> 
        <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dy</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdy = 5.500000
</span></code></pre></div><blockquote><p>Question: why do <code>y</code> and <code>dy</code> now have <code>&</code> in front when being passed to <code>__enzyme_fwddiff</code>?</p></blockquote><p>When passing information to <code>__enzyme_autodiff</code>, <code>__enzyme_fwddiff</code>:</p><ul><li>if the differentiated function takes an argument by value, then we pass it to enzyme by value</li><li>if the differentiated function takes an argument by pointer, reference or rvalue-ref, then we pass it to enzyme by pointer</li></ul><p>Link to example: <a href=https://fwd.gymni.ch/y0scib>https://fwd.gymni.ch/y0scib</a></p><p>If we want to differentiate with respect to the data members of the object (<code>x</code> in this case), we can annotate the object argument as <code>enzyme_dup</code>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>MyObject</span> <span class=n>dobj</span><span class=p>{</span><span class=mf>2.0</span><span class=p>};</span>
<span class=kt>double</span> <span class=n>dfdx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>wrapper</span><span class=o>&lt;</span><span class=n>MyObject</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span><span class=p>,</span> 
        <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> <span class=n>dobj</span> 
        <span class=n>enzyme_const</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdx = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdx</span><span class=p>);</span>
</code></pre></div><p>Link to example: <a href=https://fwd.gymni.ch/wlC87F>https://fwd.gymni.ch/wlC87F</a></p><h2 id=functors-and-lambda-functions>Functors and Lambda Functions&nbsp;<a class=headline-hash href=#functors-and-lambda-functions>¶</a></h2><p>Functors are C++ objects that implement an <code>operator()</code> member, so they can be invoked like functions. Our previous example could have been implemented in the following way instead</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>MyObject</span> <span class=p>{</span>
    <span class=kt>double</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
    <span class=kt>double</span> <span class=n>x</span><span class=p>;</span>
<span class=p>};</span>

<span class=kt>double</span> <span class=nf>wrapper</span><span class=p>(</span><span class=k>const</span> <span class=n>MyObject</span> <span class=o>&amp;</span> <span class=n>f</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>  <span class=k>return</span> <span class=n>f</span><span class=p>(</span><span class=n>y</span><span class=p>);</span> <span class=p>}</span>

<span class=p>...</span>
    
<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)(</span><span class=n>wrapper</span><span class=o>&lt;</span><span class=n>MyObject</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span><span class=p>),</span> 
    <span class=n>enzyme_const</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>obj</span><span class=p>,</span>
    <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dy</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdy = 0.750000
</span></code></pre></div><p>We can see that it is handled in the same way as regular member functions (passed to enzyme through a wrapper class).</p><hr><p>Lambda functions are another common C++ idiom for expressing function definitions in-line:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[](</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>};</span>
</code></pre></div><p>Behind the scenes, the compiler expands the definitions of the lambdas above into functor objects</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// what the compiler &#34;sees&#34; when we type 
</span><span class=c1>// auto f = [](double x, double y) { return x * y + 1.0 / y; };
</span><span class=c1></span>
<span class=k>class</span> <span class=nc>__lambda_f</span> <span class=p>{</span>
  <span class=k>public</span><span class=o>:</span> 
    <span class=kr>inline</span> <span class=cm>/*constexpr */</span> <span class=kt>double</span> <span class=k>operator</span><span class=p>()(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
      <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>*</span> <span class=n>y</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>);</span>
    <span class=p>}</span>
    
    <span class=k>using</span> <span class=n>retType_f</span> <span class=o>=</span> <span class=kt>double</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>);</span>
    <span class=kr>inline</span> <span class=k>constexpr</span> <span class=k>operator</span> <span class=nf>retType_f</span> <span class=p>()</span> <span class=k>const</span> <span class=k>noexcept</span> <span class=p>{</span>
      <span class=k>return</span> <span class=n>__invoke</span><span class=p>;</span>
    <span class=p>};</span>
    
    <span class=k>private</span><span class=o>:</span> 
    <span class=k>static</span> <span class=kr>inline</span> <span class=cm>/*constexpr */</span> <span class=kt>double</span> <span class=n>__invoke</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=n>__lambda_f</span><span class=p>{}.</span><span class=k>operator</span><span class=p>()(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
    <span class=p>}</span>    
<span class=p>};</span>

<span class=n>__lambda_f</span> <span class=n>f</span> <span class=o>=</span> <span class=n>__lambda_f</span><span class=p>{};</span>
</code></pre></div><p>This means there are a few ways to differentiate this kind of lambda function:</p><ol><li><p>Passing directly to Enzyme</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>+</span><span class=n>f</span><span class=p>,</span> 
  <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span>
  <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdx = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdx</span><span class=p>);</span>
<span class=c1>// dfdx = 6.200000
</span></code></pre></div><p>Note: since <code>f</code> doesn&rsquo;t capture anything, it can implicitly convert to a function pointer, which Enzyme can handle directly. The weird <code>+f</code> in the first argument is a rarely-used unary operator that makes <code>f</code> convert to a function pointer.</p></li><li><p>Using the member function wrapper from above</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)(</span><span class=n>wrapper</span><span class=o>&lt;</span><span class=k>decltype</span><span class=p>(</span><span class=n>f</span><span class=p>),</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span><span class=p>),</span> 
        <span class=n>enzyme_const</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>f</span><span class=p>,</span>
        <span class=n>enzyme_const</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>,</span>
        <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dy</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// dfdy = 0.750000
</span></code></pre></div><p>Note: the lambda is explicitly cast to <code>(void*)</code> to suppress a compilation error. This error arises because, regularly, C++ has no way to specialize an <code>extern</code> template like <code>__enzyme_fwddiff(...)</code> using a type in a local scope (i.e. the lambda function), but Enzyme does not have this limitation.</p></li><li><p>Using a similar wrapper with non-type template parameter (requires C++20)</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// C++20 or later
</span><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span> <span class=k>auto</span> <span class=n>obj</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span> <span class=n>arg_types</span> <span class=o>&gt;</span>
<span class=k>auto</span> <span class=n>wrapper</span><span class=p>(</span><span class=n>arg_types</span> <span class=o>&amp;&amp;</span> <span class=p>...</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>obj</span><span class=p>(</span><span class=n>args</span> <span class=p>...</span> <span class=p>);</span>
<span class=p>}</span>
   
<span class=p>...</span>
   
<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)(</span><span class=n>wrapper</span><span class=o>&lt;</span><span class=n>f</span><span class=p>,</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span><span class=p>),</span> 
    <span class=n>enzyme_const</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>,</span>
    <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dy</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// dfdy = 0.750000
</span></code></pre></div></li></ol><p>Link to examples: <a href=https://fwd.gymni.ch/wkgeoL>https://fwd.gymni.ch/wkgeoL</a></p><hr><p>Instead, if a lambda function captures variables from its surrounding scope</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=k>auto</span> <span class=n>f</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span><span class=p>](</span><span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>};</span>
</code></pre></div><p>then the compiler-generated functor object for the lambda expression is slightly different:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// what the compiler &#34;sees&#34; when we type 
</span><span class=c1>// double x = 2.0;
</span><span class=c1>// auto f = [x](double y) { return x * y + 1.0 / y; };
</span><span class=c1></span>
<span class=k>class</span> <span class=nc>__lambda_f</span>  <span class=p>{</span>
 <span class=k>public</span><span class=o>:</span> 
  <span class=kr>inline</span> <span class=cm>/*constexpr */</span> <span class=kt>double</span> <span class=k>operator</span><span class=p>()(</span><span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>x</span> <span class=o>*</span> <span class=n>y</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>);</span>
  <span class=p>}</span>
    
  <span class=n>__lambda_f</span><span class=p>(</span><span class=kt>double</span> <span class=o>&amp;</span> <span class=n>_x</span><span class=p>)</span> <span class=o>:</span> <span class=n>x</span><span class=p>{</span><span class=n>_x</span><span class=p>}{}</span>
    
 <span class=k>private</span><span class=o>:</span> 
  <span class=kt>double</span> <span class=n>x</span><span class=p>;</span>
<span class=p>};</span>

<span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=n>__lambda_f</span> <span class=n>f</span> <span class=o>=</span> <span class=n>__lambda_f</span><span class=p>{</span><span class=n>x</span><span class=p>};</span>
</code></pre></div><p>An important difference is that by capturing, the lambda no longer generates the <code>static __invoke()</code> method or the implicit conversion to a function pointer, which means option #1 above (passing directly to Enzyme) will not work.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/getting_started/CallingConvention/ title="Calling Convention"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Calling Convention</a>
<a class="nav nav-next" href=/getting_started/CUDAGuide/ title="CUDA Guide">Next - CUDA Guide <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://enzyme.mit.edu/>Home</a></li><li><a href=/Installation/>Installation</a></li><li class="parent has-sub-menu"><a href=/getting_started/>Getting Started<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/getting_started/UsingEnzyme/>Using Enzyme</a></li><li><a href=/getting_started/CallingConvention/>Calling Convention</a></li><li class=active><a href=/getting_started/Examples/>C++ Examples</a></li><li><a href=/getting_started/CUDAGuide/>CUDA Guide</a></li><li><a href=/getting_started/Faq/>FAQ</a></li></ul></li><li class=has-sub-menu><a href=/talks/>Talks, Publications, and EnzymeCon<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/talks/Talks/>Presentations</a></li><li><a href=/talks/Publications/>Related Publications</a></li><li><a href=/talks/EnzymeCon/>Enzyme Conference 2023</a></li></ul></li><li><a href=/getting_involved/>Getting Involved</a></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body);></script></div></body></html>