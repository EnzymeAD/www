<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>C++ Examples - Enzyme AD</title><meta name=description content="Enzyme Automatic Differentiation Framework"><meta name=generator content="Hugo 0.74.3"><link href=https://enzyme.mit.edu/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://enzyme.mit.edu/getting_started/Examples/><link rel=stylesheet href=https://enzyme.mit.edu/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://enzyme.mit.edu/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://enzyme.mit.edu/js/bundle.js></script><link rel=apple-touch-icon sizes=180x180 href=/favicon_io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon_io/favicon-16x16.png><link rel=manifest href=/favicon_io/site.webmanifest><script defer data-domain=enzyme.mit.edu src=https://plausible.io/js/plausible.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><a href=/ style=text-decoration:none;color:#000><img src=https://enzyme.mit.edu//logo.svg width=40px align=absmiddle>
Enzyme AD</a></div></h1><p class=description>Enzyme Automatic Differentiation Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://groups.google.com/d/forum/enzyme-dev>Discussion List</a></li></ul></li><li><a href=https://github.com/EnzymeAD/Enzyme>GitHub</a></li><li><a href=https://github.com/wsmoses/Enzyme/issues>Bugs</a></li><li><a href=/explorer>Try Online</a></li><li><a href=/conference>Conference</a></li><li><a href=/getting_started/Faq/>FAQ</a></li></ul></nav></div><div class=content-container><main><h1>C++ Examples</h1><p>There are many ways to implement a given calculation. This document contains examples of how to apply Enzyme to different kinds of patterns that show up frequently in C++. To make the code snippets below more concise, we&rsquo;ll assume that each example snippet has the following definitions prepended to the translation unit:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>int</span> <span class=n>enzyme_dup</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>enzyme_dupnoneed</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>enzyme_out</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>enzyme_const</span><span class=p>;</span>

<span class=k>template</span> <span class=o>&lt;</span> <span class=k>typename</span> <span class=n>return_type</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span> <span class=n>T</span> <span class=o>&gt;</span>
<span class=k>extern</span> <span class=n>return_type</span> <span class=n>__enzyme_fwddiff</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>T</span> <span class=p>...</span> <span class=p>);</span>

<span class=k>template</span> <span class=o>&lt;</span> <span class=k>typename</span> <span class=n>return_type</span><span class=p>,</span> <span class=k>typename</span> <span class=p>...</span> <span class=n>T</span> <span class=o>&gt;</span>
<span class=k>extern</span> <span class=n>return_type</span> <span class=n>__enzyme_autodiff</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>,</span> <span class=n>T</span> <span class=p>...</span> <span class=p>);</span>
</code></pre></div><h2 id=free-functions-return-by-value>Free Functions: Return-By-Value&nbsp;<a class=headline-hash href=#free-functions-return-by-value>¶</a></h2><p>Consider a function with one scalar input and one scalar output, \(f(x) \coloneqq x^2.\) We can implement this in C++ as a free function:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>The derivative of this function is simply \(f&rsquo;(x) = 2x\), but rather than implement that by hand, let&rsquo;s see how do it with automatically with Enzyme:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>5.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dx</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>df_dx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x) = %f, f&#39;(x) = %f&#34;</span><span class=p>,</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>df_dx</span><span class=p>);</span>
<span class=c1>// prints f(x) = 25.000000, f&#39;(x) = 10.000000
</span></code></pre></div><p>So, we first tell enzyme which function we want to differentiate and then pass arguments the arguments following <code>enzyme_dup</code> are telling enzyme where to evaluate the derivative and how much to scale the derivative (we pick <code>dx = 1.0</code> to have unit scale).</p><p>Link to example: <a href=https://fwd.gymni.ch/yeLDzF>https://fwd.gymni.ch/yeLDzF</a></p><hr><p>Next, we&rsquo;ll look at a function with two inputs and one output,
$$
f(x, y) \coloneqq x \, y + \frac{1}{y}
$$</p><p>The &ldquo;derivative&rdquo; (i.e. the Jacobian) of this function is a row vector with two entries:
$$
\bold{J} = \left[
\begin{array}{cc}
\displaystyle \frac{\partial f}{\partial x} & \displaystyle \frac{\partial f}{\partial y}
\end{array}
\right]
$$
There are two fundamental operations that involve the Jacobian:</p><ol><li>&ldquo;forward mode&rdquo; differentiation: compute \(df := \bold{J} \cdot d\bold{x}\), (where \(d\bold{x} = [dx \,\, dy]^\top\))</li><li>&ldquo;reverse mode&rdquo; differentiation: compute \(\boldsymbol{\mu} := \bold{J}^\top \lambda\)</li></ol><p>There&rsquo;s lots more to say here about when to use forward mode or reverse mode, but that&rsquo;s beyond the scope of this document, so we&rsquo;ll just focus on how to use Enzyme to perform these two kinds of differentiation for us.</p><p>Like before, start by implementing the original function</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><h4 id=forward-mode>Forward Mode&nbsp;<a class=headline-hash href=#forward-mode>¶</a></h4><p><code>__enzyme_fwddiff</code> implements forward-mode differentiation, and we use it by specifying where to evaluate \(\bold{J}\), and what values to use for \(d\bold{x}\)</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>3.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dx</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dy</span> <span class=o>=</span> <span class=mf>1.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>df</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x) = %f, df = %f&#34;</span><span class=p>,</span> <span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>),</span> <span class=n>df</span><span class=p>)</span>
<span class=c1>// prints f(x) = 6.500000, df = 4.750000
</span></code></pre></div><blockquote><p>But what if I only want to (forward) differentiate with respect to some of the inputs?</p></blockquote><p>There are two approaches:</p><ol><li><p>Set <code>dx</code> or <code>dy</code> to zeroes as needed for unwanted derivatives</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>);</span> 
<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mf>0.0</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdx = %f, dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdx</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdx = 2.000000, dfdy = 2.750000
</span></code></pre></div></li><li><p>Specify <code>enzyme_const</code> to indicate which arguments are not to be differentiated</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>double</span> <span class=n>dfdx</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span> 
<span class=kt>double</span> <span class=n>dfdy</span> <span class=o>=</span> <span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_const</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;dfdx = %f, dfdy = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dfdx</span><span class=p>,</span> <span class=n>dfdy</span><span class=p>);</span>
<span class=c1>// prints dfdx = 2.000000, dfdy = 2.750000
</span></code></pre></div></li></ol><p>Option 1 has the benefit of flexibility&ndash; we can choose to turn differentiation with respect to certain variables on or off at runtime. Option 2 hard codes which derivatives can be computed, which narrows scope and potentially improves performance. The appropriate choice will depend on the specific needs of your project.</p><p>Link to example: <a href=https://fwd.gymni.ch/xoTj9R>https://fwd.gymni.ch/xoTj9R</a></p><h4 id=reverse-mode>Reverse Mode&nbsp;<a class=headline-hash href=#reverse-mode>¶</a></h4><p><code>__enzyme_autodiff</code> implements reverse-mode differentiation. We tell enzyme which function to differentiate, and pass information about where to evaluate the Jacobian. The <code>enzyme_out</code> specifier indicates which components (i.e. rows of the vector-jacobian product \(\bold{J}^\top \lambda\)) we want</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>struct</span> <span class=nc>double2</span><span class=p>{</span> <span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span> <span class=p>};</span>

<span class=p>...</span>

<span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=mf>3.0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>y</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=k>auto</span> <span class=p>[</span><span class=n>mu_x</span><span class=p>,</span> <span class=n>mu_y</span><span class=p>]</span> <span class=o>=</span> <span class=n>__enzyme_autodiff</span><span class=o>&lt;</span><span class=n>double2</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;mu_x = %f, mu_y = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>mu_x</span><span class=p>,</span> <span class=n>mu_y</span><span class=p>);</span>
<span class=c1>// prints mu_x = 2.000000, mu_y = 2.750000
</span></code></pre></div><p>The value returned by <code>__enzyme_autodiff</code> is the concatenation of the different <code>enzyme_out</code> quantities. Here, we define a struct, <code>double2</code> to represent those output values (and use C++17 structured binding to split them into <code>mu_x, mu_y</code>).</p><blockquote><p>Note: it may be tempting to store the outputs in a <code>std::tuple&lt; double, double ></code>, but the memory layout of <code>std::tuple</code> is implementation defined (e.g. some compilers implement <code>std::tuple&lt;T, U, V></code> with <code>V</code> first, <code>U</code> second, and <code>T</code> last). So, please don&rsquo;t store the outputs of <code>__enzyme_autodiff</code> in a <code>std::tuple</code>!</p></blockquote><p>Link to example: <a href=https://fwd.gymni.ch/gPPXUg>https://fwd.gymni.ch/gPPXUg</a></p><h2 id=free-functions-return-by-reference>Free Functions: Return-By-Reference&nbsp;<a class=headline-hash href=#free-functions-return-by-reference>¶</a></h2><p>Another possible way to implement the previous function is with an out-parameter:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>double</span> <span class=n>x</span><span class=p>,</span> <span class=kt>double</span> <span class=n>y</span><span class=p>,</span> <span class=kt>double</span> <span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span> <span class=p>{</span> <span class=n>output</span> <span class=o>=</span> <span class=n>x</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>y</span><span class=p>;</span> <span class=p>}</span>
</code></pre></div><p>Differentiating functions like this with enzyme is similar to the return-by-value case, but with some small differences.</p><p>If we only care about the derivative output, and not the function value itself, we can use the <code>enzyme_dupnoneed</code> descriptor. This lets the compiler optimize away unnecessary calculations associated with evaluating the output.</p><h4 id=forward-mode-1>Forward Mode&nbsp;<a class=headline-hash href=#forward-mode-1>¶</a></h4><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// these will be overwritten by __enzyme_fwddiff
</span><span class=c1></span><span class=kt>double</span> <span class=n>z</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>dz</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=cp>#if 1
</span><span class=cp></span><span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> 
                                 <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>,</span> 
                                 <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dz</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x,y) = %f, df = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>dz</span><span class=p>);</span>
<span class=c1>// prints f(x,y) = 6.500000, df = 7.500000
</span><span class=c1></span><span class=cp>#else
</span><span class=cp></span><span class=n>__enzyme_fwddiff</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>dx</span><span class=p>,</span> 
                                 <span class=n>enzyme_dup</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>dy</span><span class=p>,</span> 
                                 <span class=n>enzyme_dupnoneed</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dz</span><span class=p>);</span>
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;f(x,y) = %f, df = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>dz</span><span class=p>);</span>
<span class=c1>// prints f(x,y) = 0.000000, df = 7.500000
</span><span class=c1></span><span class=cp>#endif
</span></code></pre></div><p>Note: the by-reference arguments of the function are passed to <code>__enzyme_fwddiff</code> by address.</p><p>Link to example: <a href=https://fwd.gymni.ch/Uxo2JG>https://fwd.gymni.ch/Uxo2JG</a></p><h4 id=reverse-mode-1>Reverse Mode&nbsp;<a class=headline-hash href=#reverse-mode-1>¶</a></h4><p>vector-Jacobian product \(\boldsymbol{\mu} := \bold{J}^\top \lambda\) is implemented as</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=c1>// lambda is an input to __enzyme_autodiff 
</span><span class=c1></span><span class=kt>double</span> <span class=n>lambda</span> <span class=o>=</span> <span class=mf>2.0</span><span class=p>;</span>
<span class=cp>#if 1
</span><span class=cp></span><span class=n>double2</span> <span class=n>mu</span> <span class=o>=</span> <span class=n>__enzyme_autodiff</span><span class=o>&lt;</span><span class=n>double2</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> 
                                                  <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> 
                                                  <span class=n>enzyme_dup</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;z = %f, mu.x = %f, mu.y = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
<span class=c1>// prints z = 6.500000, mu.x = 4.000000, mu.y = 5.500000
</span><span class=c1></span><span class=cp>#else
</span><span class=cp></span><span class=n>double2</span> <span class=n>mu</span> <span class=o>=</span> <span class=n>__enzyme_autodiff</span><span class=o>&lt;</span><span class=n>double2</span><span class=o>&gt;</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>f</span><span class=p>,</span> <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> 
                                                  <span class=n>enzyme_out</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> 
                                                  <span class=n>enzyme_dupnoneed</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>z</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>lambda</span><span class=p>);</span> 
<span class=n>printf</span><span class=p>(</span><span class=s>&#34;z = %f, mu.x = %f, mu.y = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>mu</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
<span class=c1>// prints z = 0.000000, mu.x = 4.000000, mu.y = 5.500000
</span><span class=c1></span><span class=cp>#endif
</span></code></pre></div><p>Link to example: <a href=https://fwd.gymni.ch/sfY5uu>https://fwd.gymni.ch/sfY5uu</a></p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/getting_started/CallingConvention/ title="Calling Convention"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Calling Convention</a>
<a class="nav nav-next" href=/getting_started/CUDAGuide/ title="CUDA Guide">Next - CUDA Guide <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://enzyme.mit.edu/>Home</a></li><li><a href=/Installation/>Installation</a></li><li class="parent has-sub-menu"><a href=/getting_started/>Getting Started<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/getting_started/UsingEnzyme/>Using Enzyme</a></li><li><a href=/getting_started/CallingConvention/>Calling Convention</a></li><li class=active><a href=/getting_started/Examples/>C++ Examples</a></li><li><a href=/getting_started/CUDAGuide/>CUDA Guide</a></li><li><a href=/getting_started/Faq/>FAQ</a></li></ul></li><li class=has-sub-menu><a href=/talks/>Talks, Publications, and EnzymeCon<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/talks/Talks/>Presentations</a></li><li><a href=/talks/Publications/>Related Publications</a></li><li><a href=/talks/EnzymeCon/>Enzyme Conference 2023</a></li></ul></li><li><a href=/getting_involved/>Getting Involved</a></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body);></script></div></body></html>