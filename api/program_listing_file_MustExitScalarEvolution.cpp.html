


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File MustExitScalarEvolution.cpp &mdash; Enzyme Sphinx Theme 0.0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <!-- Google Analytics -->
  
  <!-- End Google Analytics -->
  

  
  <script src="../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-book.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/FreightSans/freight-sans-medium-italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://enzyme.mit.edu" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="https://enzyme.mit.edu/get-started">Get Started</a>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Languages
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://enzyme.mit.edu/docs/stable/index.html">
                  <span class="dropdown-title">Julia</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="">
                  <span class="dropdown-title">Rust</span>
                  <p></p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://enzyme.mit.edu/features">
                  <span class="dropdown-title">About</span>
                  <p>Learn about Enzyme’s features and capabilities</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community</span>
                  <p>Join the Enzyme developer community to contribute, learn, and get your questions answered.</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Developer Resources</span>
                  <p>Developer documentation, templates and tools </p>
                </a>
                <a class="nav-dropdown-item" href="" target="_blank">
                  <span class="dropdown-title">Forums</span>
                  <p>A place to discuss Enzyme code, issues, install.</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <a href="https://github.com/EnzymeAD/enzyme">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="enzyme-body">

   

    

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="enzyme-left-menu" id="enzyme-left-menu">
      <div class="enzyme-side-scroll">
        <div class="enzyme-menu enzyme-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="enzyme-left-menu-search">
            

            
              
              
                <div class="version">
                  0.0.1
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../starting/ad_intro_using_enzyme.html">Introduction to Automatic Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../starting/compiler_based_ad.html">The Stages of Compiler-based Automatic Differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../starting/installation.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../starting/multi_source_ad.html">AD of Multi-Source Programs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Bindings</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://enzyme.mit.edu/cpp/">C/C++</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enzyme.mit.edu/fortran/">Fortran</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enzyme.mit.edu/julia/">Julia</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enzyme.mit.edu/rust/">Rust</a></li>
<li class="toctree-l1"><a class="reference external" href="https://enzyme.mit.edu/swift/">Swift</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../calling_convention.html">Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../troubleshooting_and_tips.html">Troubleshooting and Tips</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Applications and Code Examples of Enzyme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../talks_and_tutorials.html">Talks and Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../advanced/advanced_options.html">Advanced options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/cuda_guide.html">CUDA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/mpi_guide.html">MPI-Primitives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/openmp_guide.html">OpenMP Directives and Constructs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/rocm_guide.html">ROCm</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="enzyme-container">
      <div class="enzyme-page-level-bar" id="enzyme-page-level-bar">
        <div class="enzyme-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="enzyme-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
      <li>Program Listing for File MustExitScalarEvolution.cpp</li>
    
    
      <li class="enzyme-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_MustExitScalarEvolution.cpp.rst.txt" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="enzyme-shortcuts-wrapper" id="enzyme-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="enzyme-content-wrap" class="enzyme-content-wrap">
        <div class="enzyme-content-left">

        
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="enzyme-article" class="enzyme-article">
              
  <section id="program-listing-for-file-mustexitscalarevolution-cpp">
<span id="program-listing-file-mustexitscalarevolution-cpp"></span><h1>Program Listing for File MustExitScalarEvolution.cpp<a class="headerlink" href="#program-listing-for-file-mustexitscalarevolution-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_MustExitScalarEvolution.cpp.html#file-mustexitscalarevolution-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">MustExitScalarEvolution.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//===- MustExitScalarEvolution.cpp - ScalarEvolution assuming loops</span>
<span class="c1">// terminate-=//</span>
<span class="c1">//</span>
<span class="c1">//                             Enzyme Project</span>
<span class="c1">//</span>
<span class="c1">// Part of the Enzyme Project, under the Apache License v2.0 with LLVM</span>
<span class="c1">// Exceptions. See https://llvm.org/LICENSE.txt for license information.</span>
<span class="c1">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span>
<span class="c1">//</span>
<span class="c1">// If using this code in an academic setting, please cite the following:</span>
<span class="c1">// @incollection{enzymeNeurips,</span>
<span class="c1">// title = {Instead of Rewriting Foreign Code for Machine Learning,</span>
<span class="c1">//          Automatically Synthesize Fast Gradients},</span>
<span class="c1">// author = {Moses, William S. and Churavy, Valentin},</span>
<span class="c1">// booktitle = {Advances in Neural Information Processing Systems 33},</span>
<span class="c1">// year = {2020},</span>
<span class="c1">// note = {To appear in},</span>
<span class="c1">// }</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines MustExitScalarEvolution, a subclass of ScalarEvolution</span>
<span class="c1">// that assumes that all loops terminate (and don&#39;t loop forever).</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;MustExitScalarEvolution.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;FunctionUtils.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/Analysis/LoopInfo.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/Analysis/ScalarEvolution.h&quot;</span><span class="cp"></span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">llvm</span><span class="p">;</span><span class="w"></span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">MustExitScalarEvolution::loopIsFiniteByAssumption</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#if LLVM_VERSION_MAJOR &gt;= 7</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="nf">MustExitScalarEvolution::computeExitLimitFromCond</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimitCacheTy</span><span class="w"> </span><span class="n">Cache</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="nf">MustExitScalarEvolution::computeExitLimitFromCond</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">FBB</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimitCacheTy</span><span class="w"> </span><span class="n">Cache</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">MustExitScalarEvolution</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Function</span><span class="w"> </span><span class="o">&amp;</span><span class="n">F</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">llvm</span><span class="o">::</span><span class="n">TargetLibraryInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">TLI</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">llvm</span><span class="o">::</span><span class="n">AssumptionCache</span><span class="w"> </span><span class="o">&amp;</span><span class="n">AC</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">llvm</span><span class="o">::</span><span class="n">DominatorTree</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DT</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">llvm</span><span class="o">::</span><span class="n">LoopInfo</span><span class="w"> </span><span class="o">&amp;</span><span class="n">LI</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">TLI</span><span class="p">,</span><span class="w"> </span><span class="n">AC</span><span class="p">,</span><span class="w"> </span><span class="n">DT</span><span class="p">,</span><span class="w"> </span><span class="n">LI</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">GuaranteedUnreachable</span><span class="p">(</span><span class="n">getGuaranteedUnreachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">F</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimit</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">ExitingBlock</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ExitingBlocks</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">getExitingBlocks</span><span class="p">(</span><span class="n">ExitingBlocks</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ExitingBlock</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ExitingBlocks</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">Exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">SBB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">successors</span><span class="p">(</span><span class="n">ExitingBlock</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">SBB</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GuaranteedUnreachable</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">SBB</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SBB</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Exit</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitingBlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">ExitingBlocks</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">ExitingBlocks</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">ExitingBlocks</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitingBlocks</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">ExitingBlock</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Exit count for non-loop block?&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If our exiting block does not dominate the latch, then its connection with</span>
<span class="w">  </span><span class="c1">// loop&#39;s exit limit may be far from trivial.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">Latch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">getLoopLatch</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Latch</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">DT</span><span class="p">.</span><span class="n">dominates</span><span class="p">(</span><span class="n">ExitingBlock</span><span class="p">,</span><span class="w"> </span><span class="n">Latch</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsOnlyExit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitingBlocks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">Term</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitingBlock</span><span class="o">-&gt;</span><span class="n">getTerminator</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BranchInst</span><span class="w"> </span><span class="o">*</span><span class="n">BI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BranchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Term</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">isConditional</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;If unconditional, it can&#39;t be in loop!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">ExitIfTrue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">           </span><span class="s">&quot;It should have one successor in loop and one exit block!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Proceed to the next level to examine the exit condition expression.</span>
<span class="cp">#if LLVM_VERSION_MAJOR &gt;= 7</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">getCondition</span><span class="p">(),</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="cm">/*ControlsExit=*/</span><span class="n">IsOnlyExit</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromCond</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">getCondition</span><span class="p">(),</span><span class="w"> </span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">BI</span><span class="o">-&gt;</span><span class="n">getSuccessor</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*ControlsExit=*/</span><span class="n">IsOnlyExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="cp">#endif</span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SwitchInst</span><span class="w"> </span><span class="o">*</span><span class="n">SI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SwitchInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Term</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// For switch, make sure that there is a single exit from the loop.</span>
<span class="w">    </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">Exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">SBB</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">successors</span><span class="p">(</span><span class="n">ExitingBlock</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">SBB</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">GuaranteedUnreachable</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">SBB</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">continue</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Exit</span><span class="p">)</span><span class="w"> </span><span class="c1">// Multiple exit successors.</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">Exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SBB</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">Exit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Exiting block must have at least one exit&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromSingleExitSwitch</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">SI</span><span class="p">,</span><span class="w"> </span><span class="n">Exit</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                </span><span class="cm">/*ControlsExit=*/</span><span class="n">IsOnlyExit</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#if LLVM_VERSION_MAJOR &gt;= 7</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"></span>
<span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimitCacheTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">MaybeEL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">MaybeEL</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondImpl</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">                                              </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Cache</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">,</span><span class="w"> </span><span class="n">EL</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"></span>
<span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimitCacheTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">TBB</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">MaybeEL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">MaybeEL</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondImpl</span><span class="p">(</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"></span>
<span class="w">                                              </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">Cache</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">,</span><span class="w"> </span><span class="n">EL</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#if LLVM_VERSION_MAJOR &gt;= 7</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"></span>
<span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimitFromCondImpl</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimitCacheTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Check if the controlling expression for this loop is an And or Or.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BinaryOperator</span><span class="w"> </span><span class="o">*</span><span class="n">BO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Instruction</span><span class="o">::</span><span class="n">And</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Recurse on the operands of the and.</span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">EitherMayExit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">ExitIfTrue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EitherMayExit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be true for the loop to continue executing.</span>
<span class="w">        </span><span class="c1">// Choose the less conservative count.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">            </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be true at the same time for the loop to exit.</span>
<span class="w">        </span><span class="c1">// For now, be conservative.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// There are cases (e.g. PR26207) where computeExitLimitFromCond is able</span>
<span class="w">      </span><span class="c1">// to be more aggressive when computing BECount than when computing</span>
<span class="w">      </span><span class="c1">// MaxBECount.  In these cases it is possible for EL0.ExactNotTaken and</span>
<span class="w">      </span><span class="c1">// EL1.ExactNotTaken to match, but for EL0.MaxNotTaken and EL1.MaxNotTaken</span>
<span class="w">      </span><span class="c1">// to not.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaxBECount</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConstant</span><span class="p">(</span><span class="n">getUnsignedRangeMax</span><span class="p">(</span><span class="n">BECount</span><span class="p">));</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">BECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="p">{</span><span class="o">&amp;</span><span class="n">EL0</span><span class="p">.</span><span class="n">Predicates</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EL1</span><span class="p">.</span><span class="n">Predicates</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Instruction</span><span class="o">::</span><span class="n">Or</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Recurse on the operands of the or.</span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">EitherMayExit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EitherMayExit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be false for the loop to continue executing.</span>
<span class="w">        </span><span class="c1">// Choose the less conservative count.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">            </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be false at the same time for the loop to exit.</span>
<span class="w">        </span><span class="c1">// For now, be conservative.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">BECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="p">{</span><span class="o">&amp;</span><span class="n">EL0</span><span class="p">.</span><span class="n">Predicates</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EL1</span><span class="p">.</span><span class="n">Predicates</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// With an icmp, it may be feasible to compute an exact backedge-taken count.</span>
<span class="w">  </span><span class="c1">// Proceed to the next level to examine the icmp.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ICmpInst</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCondICmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ICmpInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">computeExitLimitFromICmp</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCondICmp</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasFullInfo</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Try again, but use SCEV predicates this time.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromICmp</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCondICmp</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="cm">/*AllowPredicates=*/</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Check for a constant condition. These are normally stripped out by</span>
<span class="w">  </span><span class="c1">// SimplifyCFG, but ScalarEvolution may be used by a pass which wishes to</span>
<span class="w">  </span><span class="c1">// preserve the CFG and is temporarily leaving constant conditions</span>
<span class="w">  </span><span class="c1">// in place.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ConstantInt</span><span class="w"> </span><span class="o">*</span><span class="n">CI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ExitIfTrue</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">!</span><span class="n">CI</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="c1">// The backedge is always taken.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="c1">// The backedge is never taken.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getZero</span><span class="p">(</span><span class="n">CI</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If it&#39;s not an integer or pointer comparison then compute it the hard way.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitCountExhaustively</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"></span>
<span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimitFromCondImpl</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimitCacheTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">TBB</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Check if the controlling expression for this loop is an And or Or.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BinaryOperator</span><span class="w"> </span><span class="o">*</span><span class="n">BO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BinaryOperator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Instruction</span><span class="o">::</span><span class="n">And</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Recurse on the operands of the and.</span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">EitherMayExit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">TBB</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EitherMayExit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be true for the loop to continue executing.</span>
<span class="w">        </span><span class="c1">// Choose the less conservative count.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">            </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be true at the same time for the loop to exit.</span>
<span class="w">        </span><span class="c1">// For now, be conservative.</span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">FBB</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Loop block has no successor in loop!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="c1">// There are cases (e.g. PR26207) where computeExitLimitFromCond is able</span>
<span class="w">      </span><span class="c1">// to be more aggressive when computing BECount than when computing</span>
<span class="w">      </span><span class="c1">// MaxBECount.  In these cases it is possible for EL0.ExactNotTaken and</span>
<span class="w">      </span><span class="c1">// EL1.ExactNotTaken to match, but for EL0.MaxNotTaken and EL1.MaxNotTaken</span>
<span class="w">      </span><span class="c1">// to not.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaxBECount</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">          </span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConstant</span><span class="p">(</span><span class="n">getUnsignedRangeMax</span><span class="p">(</span><span class="n">BECount</span><span class="p">));</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">BECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="p">{</span><span class="o">&amp;</span><span class="n">EL0</span><span class="p">.</span><span class="n">Predicates</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EL1</span><span class="p">.</span><span class="n">Predicates</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Instruction</span><span class="o">::</span><span class="n">Or</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Recurse on the operands of the or.</span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">EitherMayExit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">FBB</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitLimitFromCondCached</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Cache</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">BO</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">EitherMayExit</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EitherMayExit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be false for the loop to continue executing.</span>
<span class="w">        </span><span class="c1">// Choose the less conservative count.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">            </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">())</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">              </span><span class="n">getUMinFromMismatchedTypes</span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">,</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Both conditions must be false at the same time for the loop to exit.</span>
<span class="w">        </span><span class="c1">// For now, be conservative.</span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">TBB</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Loop block has no successor in loop!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">MaxNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EL1</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">)</span><span class="w"></span>
<span class="w">          </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EL0</span><span class="p">.</span><span class="n">ExactNotTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">BECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"></span>
<span class="w">                       </span><span class="p">{</span><span class="o">&amp;</span><span class="n">EL0</span><span class="p">.</span><span class="n">Predicates</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">EL1</span><span class="p">.</span><span class="n">Predicates</span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// With an icmp, it may be feasible to compute an exact backedge-taken count.</span>
<span class="w">  </span><span class="c1">// Proceed to the next level to examine the icmp.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ICmpInst</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCondICmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ICmpInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">computeExitLimitFromICmp</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCondICmp</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasFullInfo</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Try again, but use SCEV predicates this time.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitLimitFromICmp</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCondICmp</span><span class="p">,</span><span class="w"> </span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">FBB</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"></span>
<span class="w">                                    </span><span class="cm">/*AllowPredicates=*/</span><span class="nb">true</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Check for a constant condition. These are normally stripped out by</span>
<span class="w">  </span><span class="c1">// SimplifyCFG, but ScalarEvolution may be used by a pass which wishes to</span>
<span class="w">  </span><span class="c1">// preserve the CFG and is temporarily leaving constant conditions</span>
<span class="w">  </span><span class="c1">// in place.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ConstantInt</span><span class="w"> </span><span class="o">*</span><span class="n">CI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantInt</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">FBB</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">!</span><span class="n">CI</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="c1">// The backedge is always taken.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">else</span><span class="w"></span>
<span class="w">      </span><span class="c1">// The backedge is never taken.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getZero</span><span class="p">(</span><span class="n">CI</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If it&#39;s not an integer or pointer comparison then compute it the hard way.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">computeExitCountExhaustively</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">TBB</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#if LLVM_VERSION_MAJOR &gt;= 7</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimitFromICmp</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ICmpInst</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If the condition was exit on true, convert the condition to exit on false</span>
<span class="w">  </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">Pred</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ExitIfTrue</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getPredicate</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getInversePredicate</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">OriginalPred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pred</span><span class="p">;</span><span class="w"></span>

<span class="cp">#if LLVM_VERSION_MAJOR &lt; 14</span>
<span class="w">  </span><span class="c1">// Handle common loops like: for (X = &quot;string&quot;; *X; ++X)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LoadInst</span><span class="w"> </span><span class="o">*</span><span class="n">LI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">LoadInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Constant</span><span class="w"> </span><span class="o">*</span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">ItCnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeLoadConstantCompareExitLimit</span><span class="p">(</span><span class="n">LI</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Pred</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ItCnt</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ItCnt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">LHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEV</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEV</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="cp">#define PROP_PHI(LHS)                                                          \</span>
<span class="cp">  if (auto un = dyn_cast&lt;SCEVUnknown&gt;(LHS)) {                                  \</span>
<span class="cp">    if (auto pn = dyn_cast_or_null&lt;PHINode&gt;(un-&gt;getValue())) {                 \</span>
<span class="cp">      const SCEV *sc = nullptr;                                                \</span>
<span class="cp">      bool failed = false;                                                     \</span>
<span class="cp">      for (auto &amp;a : pn-&gt;incoming_values()) {                                  \</span>
<span class="cp">        auto subsc = getSCEV(a);                                               \</span>
<span class="cp">        if (sc == nullptr) {                                                   \</span>
<span class="cp">          sc = subsc;                                                          \</span>
<span class="cp">          continue;                                                            \</span>
<span class="cp">        }                                                                      \</span>
<span class="cp">        if (subsc != sc) {                                                     \</span>
<span class="cp">          failed = true;                                                       \</span>
<span class="cp">          break;                                                               \</span>
<span class="cp">        }                                                                      \</span>
<span class="cp">      }                                                                        \</span>
<span class="cp">      if (!failed) {                                                           \</span>
<span class="cp">        LHS = sc;                                                              \</span>
<span class="cp">      }                                                                        \</span>
<span class="cp">    }                                                                          \</span>
<span class="cp">  }</span>
<span class="w">  </span><span class="n">PROP_PHI</span><span class="p">(</span><span class="n">LHS</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">PROP_PHI</span><span class="p">(</span><span class="n">RHS</span><span class="p">)</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Try to evaluate any dependencies out of the loop.</span>
<span class="w">  </span><span class="n">LHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEVAtScope</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEVAtScope</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// At this point, we would like to compute how many iterations of the</span>
<span class="w">  </span><span class="c1">// loop the predicate will return true for these inputs.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If there is a loop-invariant, force it into the RHS.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">getSwappedPredicate</span><span class="p">(</span><span class="n">Pred</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Simplify the operands before analyzing them.</span>
<span class="w">  </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">SimplifyICmpOperands</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If we have a comparison of a chrec against a constant, try to use value</span>
<span class="w">  </span><span class="c1">// ranges to answer this query.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVConstant</span><span class="w"> </span><span class="o">*</span><span class="n">RHSC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">AddRec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AddRec</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Form the constant range.</span>
<span class="w">        </span><span class="n">ConstantRange</span><span class="w"> </span><span class="n">CompRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="n">ConstantRange</span><span class="o">::</span><span class="n">makeExactICmpRegion</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">RHSC</span><span class="o">-&gt;</span><span class="n">getAPInt</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddRec</span><span class="o">-&gt;</span><span class="n">getNumIterationsInRange</span><span class="p">(</span><span class="n">CompRange</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ret</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">Ret</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Pred</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_NE</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X != Y)</span>
<span class="w">    </span><span class="c1">// Convert to: while (X-Y != 0)</span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">howFarToZero</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_EQ</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X == Y)</span>
<span class="w">    </span><span class="c1">// Convert to: while (X-Y == 0)</span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">howFarToNonZero</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULE</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X &lt; Y)</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">RHS</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">getConstant</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">IntegerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">))};</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Since this is not an infinite loop by induction, RHS cannot be</span>
<span class="w">      </span><span class="c1">// int_max/uint_max Therefore adding 1 does not wrap.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsSigned</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">howManyLessThans</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGE</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGE</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X &gt; Y)</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGT</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">RHS</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">getConstant</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">IntegerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="mi">-1</span><span class="p">))};</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Since this is not an infinite loop by induction, RHS cannot be</span>
<span class="w">      </span><span class="c1">// int_min/uint_min Therefore subtracting 1 does not wrap.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsSigned</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">howManyGreaterThans</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">ExhaustiveCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeExitCountExhaustively</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">ExitIfTrue</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExhaustiveCount</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ExhaustiveCount</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">computeShiftCompareExitLimit</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">                                      </span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">OriginalPred</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">computeExitLimitFromICmp</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ICmpInst</span><span class="w"> </span><span class="o">*</span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">TBB</span><span class="p">,</span><span class="w"> </span><span class="n">BasicBlock</span><span class="w"> </span><span class="o">*</span><span class="n">FBB</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If the condition was exit on true, convert the condition to exit on false</span>
<span class="w">  </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">Pred</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">FBB</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getPredicate</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"></span>
<span class="w">    </span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getInversePredicate</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">OriginalPred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pred</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Handle common loops like: for (X = &quot;string&quot;; *X; ++X)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LoadInst</span><span class="w"> </span><span class="o">*</span><span class="n">LI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">LoadInst</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Constant</span><span class="w"> </span><span class="o">*</span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">Constant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">ItCnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeLoadConstantCompareExitLimit</span><span class="p">(</span><span class="n">LI</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Pred</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ItCnt</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ItCnt</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">LHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEV</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEV</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Try to evaluate any dependencies out of the loop.</span>
<span class="w">  </span><span class="n">LHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEVAtScope</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getSCEVAtScope</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// At this point, we would like to compute how many iterations of the</span>
<span class="w">  </span><span class="c1">// loop the predicate will return true for these inputs.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If there is a loop-invariant, force it into the RHS.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">getSwappedPredicate</span><span class="p">(</span><span class="n">Pred</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Simplify the operands before analyzing them.</span>
<span class="w">  </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">SimplifyICmpOperands</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If we have a comparison of a chrec against a constant, try to use value</span>
<span class="w">  </span><span class="c1">// ranges to answer this query.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVConstant</span><span class="w"> </span><span class="o">*</span><span class="n">RHSC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">AddRec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AddRec</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Form the constant range.</span>
<span class="w">        </span><span class="n">ConstantRange</span><span class="w"> </span><span class="n">CompRange</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">            </span><span class="n">ConstantRange</span><span class="o">::</span><span class="n">makeExactICmpRegion</span><span class="p">(</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">RHSC</span><span class="o">-&gt;</span><span class="n">getAPInt</span><span class="p">());</span><span class="w"></span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddRec</span><span class="o">-&gt;</span><span class="n">getNumIterationsInRange</span><span class="p">(</span><span class="n">CompRange</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ret</span><span class="p">))</span><span class="w"></span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">Ret</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Pred</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_NE</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X != Y)</span>
<span class="w">    </span><span class="c1">// Convert to: while (X-Y != 0)</span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">howFarToZero</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_EQ</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X == Y)</span>
<span class="w">    </span><span class="c1">// Convert to: while (X-Y == 0)</span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">howFarToNonZero</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULE</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X &lt; Y)</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">RHS</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">getConstant</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">IntegerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="mi">1</span><span class="p">))};</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Since this is not an infinite loop by induction, RHS cannot be</span>
<span class="w">      </span><span class="c1">// int_max/uint_max Therefore adding 1 does not wrap.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsSigned</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">howManyLessThans</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGT</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGE</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGE</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// while (X &gt; Y)</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGT</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLE</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Pred</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">RHS</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="n">getConstant</span><span class="p">(</span><span class="n">ConstantInt</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">IntegerType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="mi">-1</span><span class="p">))};</span><span class="w"></span>
<span class="w">      </span><span class="c1">// Since this is not an infinite loop by induction, RHS cannot be</span>
<span class="w">      </span><span class="c1">// int_min/uint_min Therefore subtracting 1 does not wrap.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsSigned</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">else</span><span class="w"></span>
<span class="w">        </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">EL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">howManyGreaterThans</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"></span>
<span class="w">                                       </span><span class="n">AllowPredicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">EL</span><span class="p">.</span><span class="n">hasAnyInfo</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">EL</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">ExhaustiveCount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">computeExitCountExhaustively</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">ExitCond</span><span class="p">,</span><span class="w"> </span><span class="o">!</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">TBB</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ExhaustiveCount</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ExhaustiveCount</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">computeShiftCompareExitLimit</span><span class="p">(</span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">                                      </span><span class="n">ExitCond</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">OriginalPred</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>

<span class="cp">#if LLVM_VERSION_MAJOR &gt;= 13</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">getSignedOverflowLimitForStep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Step</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="o">*</span><span class="n">Pred</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                 </span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">BitWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">Step</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">isKnownPositive</span><span class="p">(</span><span class="n">Step</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getConstant</span><span class="p">(</span><span class="n">APInt</span><span class="o">::</span><span class="n">getSignedMinValue</span><span class="p">(</span><span class="n">BitWidth</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                           </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getSignedRangeMax</span><span class="p">(</span><span class="n">Step</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">isKnownNegative</span><span class="p">(</span><span class="n">Step</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getConstant</span><span class="p">(</span><span class="n">APInt</span><span class="o">::</span><span class="n">getSignedMaxValue</span><span class="p">(</span><span class="n">BitWidth</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                           </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getSignedRangeMin</span><span class="p">(</span><span class="n">Step</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">getUnsignedOverflowLimitForStep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Step</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                   </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="o">*</span><span class="n">Pred</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                   </span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">BitWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">Step</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">Pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULT</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getConstant</span><span class="p">(</span><span class="n">APInt</span><span class="o">::</span><span class="n">getMinValue</span><span class="p">(</span><span class="n">BitWidth</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"></span>
<span class="w">                         </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getUnsignedRangeMax</span><span class="p">(</span><span class="n">Step</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">namespace</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ExtendOpTraitsBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">ScalarEvolution</span><span class="o">::*</span><span class="n">GetExtendExprTy</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"></span>
<span class="w">                                                          </span><span class="kt">unsigned</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Used to make code generic over signed and unsigned overflow.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ExtendOp</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ExtendOpTraits</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Members present:</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// static const SCEV::NoWrapFlags WrapType;</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// static const ExtendOpTraitsBase::GetExtendExprTy GetExtendExpr;</span>
<span class="w">  </span><span class="c1">//</span>
<span class="w">  </span><span class="c1">// static const SCEV *getOverflowLimitForStep(const SCEV *Step,</span>
<span class="w">  </span><span class="c1">//                                           ICmpInst::Predicate *Pred,</span>
<span class="w">  </span><span class="c1">//                                           ScalarEvolution *SE);</span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">SCEVSignExtendExpr</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExtendOpTraitsBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">WrapType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">GetExtendExprTy</span><span class="w"> </span><span class="n">GetExtendExpr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="nf">getOverflowLimitForStep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Step</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="o">*</span><span class="n">Pred</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getSignedOverflowLimitForStep</span><span class="p">(</span><span class="n">Step</span><span class="p">,</span><span class="w"> </span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">SE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">ExtendOpTraitsBase</span><span class="o">::</span><span class="n">GetExtendExprTy</span><span class="w"></span>
<span class="w">    </span><span class="n">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">SCEVSignExtendExpr</span><span class="o">&gt;::</span><span class="n">GetExtendExpr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">getSignExtendExpr</span><span class="p">;</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">SCEVZeroExtendExpr</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExtendOpTraitsBase</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">WrapType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">GetExtendExprTy</span><span class="w"> </span><span class="n">GetExtendExpr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="nf">getOverflowLimitForStep</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Step</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="o">*</span><span class="n">Pred</span><span class="p">,</span><span class="w"></span>
<span class="w">                                             </span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getUnsignedOverflowLimitForStep</span><span class="p">(</span><span class="n">Step</span><span class="p">,</span><span class="w"> </span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">SE</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="n">ExtendOpTraitsBase</span><span class="o">::</span><span class="n">GetExtendExprTy</span><span class="w"></span>
<span class="w">    </span><span class="n">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">SCEVZeroExtendExpr</span><span class="o">&gt;::</span><span class="n">GetExtendExpr</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">getZeroExtendExpr</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"> </span><span class="c1">// end anonymous namespace</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">hasFlags</span><span class="p">(</span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">TestFlags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">TestFlags</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">maskFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">TestFlags</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ExtendOpTy</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">getPreStartForExtend</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">AR</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">Ty</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">WrapType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">ExtendOpTy</span><span class="o">&gt;::</span><span class="n">WrapType</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">GetExtendExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">ExtendOpTy</span><span class="o">&gt;::</span><span class="n">GetExtendExpr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getStart</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getStepRecurrence</span><span class="p">(</span><span class="o">*</span><span class="n">SE</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Check for a simple looking step prior to loop entry.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddExpr</span><span class="w"> </span><span class="o">*</span><span class="n">SA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Start</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">SA</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Create an AddExpr for &quot;PreStart&quot; after subtracting Step. Full SCEV</span>
<span class="w">  </span><span class="c1">// subtraction is expensive. For this purpose, perform a quick and dirty</span>
<span class="w">  </span><span class="c1">// difference, by checking for Step in the operand list.</span>
<span class="w">  </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DiffOps</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Op</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SA</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Op</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Step</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="n">DiffOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">DiffOps</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SA</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Try to prove `WrapType` (SCEV::FlagNSW or SCEV::FlagNUW) on `PreStart` +</span>
<span class="w">  </span><span class="c1">// `Step`:</span>

<span class="w">  </span><span class="c1">// 1. NSW/NUW flags on the step increment.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">PreStartFlags</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">maskFlags</span><span class="p">(</span><span class="n">SA</span><span class="o">-&gt;</span><span class="n">getNoWrapFlags</span><span class="p">(),</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">PreStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">DiffOps</span><span class="p">,</span><span class="w"> </span><span class="n">PreStartFlags</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">PreAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getAddRecExpr</span><span class="p">(</span><span class="n">PreStart</span><span class="p">,</span><span class="w"> </span><span class="n">Step</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagAnyWrap</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="c1">// &quot;{S,+,X} is &lt;nsw&gt;/&lt;nuw&gt;&quot; and &quot;the backedge is taken at least once&quot; implies</span>
<span class="w">  </span><span class="c1">// &quot;S+X does not sign/unsign-overflow&quot;.</span>
<span class="w">  </span><span class="c1">//</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getBackedgeTakenCount</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PreAR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">PreAR</span><span class="o">-&gt;</span><span class="n">getNoWrapFlags</span><span class="p">(</span><span class="n">WrapType</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">isKnownPositive</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PreStart</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 2. Direct overflow check on the step operation&#39;s expression.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">BitWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">WideTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntegerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">(),</span><span class="w"> </span><span class="n">BitWidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">OperandExtendedStart</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getAddExpr</span><span class="p">((</span><span class="n">SE</span><span class="o">-&gt;*</span><span class="n">GetExtendExpr</span><span class="p">)(</span><span class="n">PreStart</span><span class="p">,</span><span class="w"> </span><span class="n">WideTy</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">),</span><span class="w"></span>
<span class="w">                     </span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;*</span><span class="n">GetExtendExpr</span><span class="p">)(</span><span class="n">Step</span><span class="p">,</span><span class="w"> </span><span class="n">WideTy</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">SE</span><span class="o">-&gt;*</span><span class="n">GetExtendExpr</span><span class="p">)(</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">WideTy</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">OperandExtendedStart</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PreAR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getNoWrapFlags</span><span class="p">(</span><span class="n">WrapType</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// If we know `AR` == {`PreStart`+`Step`,+,`Step`} is `WrapType` (FlagNSW</span>
<span class="w">      </span><span class="c1">// or FlagNUW) and that `PreStart` + `Step` is `WrapType` too, then</span>
<span class="w">      </span><span class="c1">// `PreAR` == {`PreStart`,+,`Step`} is also `WrapType`.  Cache this fact.</span>
<span class="w">      </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">setNoWrapFlags</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">PreAR</span><span class="p">),</span><span class="w"> </span><span class="n">WrapType</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PreStart</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// 3. Loop precondition.</span>
<span class="w">  </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">Pred</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">OverflowLimit</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">ExtendOpTy</span><span class="o">&gt;::</span><span class="n">getOverflowLimitForStep</span><span class="p">(</span><span class="n">Step</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">SE</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OverflowLimit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Pred</span><span class="p">,</span><span class="w"> </span><span class="n">PreStart</span><span class="p">,</span><span class="w"> </span><span class="n">OverflowLimit</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">PreStart</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ExtendOpTy</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">getExtendAddRecStart</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">AR</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">Ty</span><span class="p">,</span><span class="w"></span>
<span class="w">                                        </span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">Depth</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">GetExtendExpr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExtendOpTraits</span><span class="o">&lt;</span><span class="n">ExtendOpTy</span><span class="o">&gt;::</span><span class="n">GetExtendExpr</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">PreStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getPreStartForExtend</span><span class="o">&lt;</span><span class="n">ExtendOpTy</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AR</span><span class="p">,</span><span class="w"> </span><span class="n">Ty</span><span class="p">,</span><span class="w"> </span><span class="n">SE</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">PreStart</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;*</span><span class="n">GetExtendExpr</span><span class="p">)(</span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getStart</span><span class="p">(),</span><span class="w"> </span><span class="n">Ty</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getAddExpr</span><span class="p">(</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;*</span><span class="n">GetExtendExpr</span><span class="p">)(</span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getStepRecurrence</span><span class="p">(</span><span class="o">*</span><span class="n">SE</span><span class="p">),</span><span class="w"> </span><span class="n">Ty</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">),</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;*</span><span class="n">GetExtendExpr</span><span class="p">)(</span><span class="n">PreStart</span><span class="p">,</span><span class="w"> </span><span class="n">Ty</span><span class="p">,</span><span class="w"> </span><span class="n">Depth</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">StrengthenNoWrapFlags</span><span class="p">(</span><span class="n">ScalarEvolution</span><span class="w"> </span><span class="o">*</span><span class="n">SE</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="n">SCEVTypes</span><span class="w"> </span><span class="n">Type</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="k">const</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">Ops</span><span class="p">,</span><span class="w"></span>
<span class="w">                                               </span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">Flags</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="o">::</span><span class="nn">placeholders</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">OBO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OverflowingBinaryOperator</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">CanAnalyze</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scAddExpr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scAddRecExpr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scMulExpr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">CanAnalyze</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">CanAnalyze</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;don&#39;t call from other places!&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">SignOrUnsignMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="w"> </span><span class="n">SignOrUnsignWrap</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">maskFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SignOrUnsignMask</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If FlagNSW is true and all the operands are non-negative, infer FlagNUW.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">IsKnownNonNegative</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">S</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">isKnownNonNegative</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SignOrUnsignWrap</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">all_of</span><span class="p">(</span><span class="n">Ops</span><span class="p">,</span><span class="w"> </span><span class="n">IsKnownNonNegative</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SCEV</span><span class="o">::</span><span class="n">NoWrapFlags</span><span class="p">)</span><span class="n">SignOrUnsignMask</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">SignOrUnsignWrap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">maskFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SignOrUnsignMask</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SignOrUnsignWrap</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SignOrUnsignMask</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scAddExpr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scMulExpr</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Ops</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">Opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">scAddExpr</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Instruction</span><span class="o">::</span><span class="n">Add</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">case</span><span class="w"> </span><span class="nl">scMulExpr</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Instruction</span><span class="o">::</span><span class="n">Mul</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">default</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unexpected SCEV op.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}();</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">APInt</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">getAPInt</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// (A &lt;opcode&gt; C) --&gt; (A &lt;opcode&gt; C)&lt;nsw&gt; if the op doesn&#39;t sign overflow.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SignOrUnsignWrap</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">NSWRegion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConstantRange</span><span class="o">::</span><span class="n">makeGuaranteedNoWrapRegion</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">OBO</span><span class="o">::</span><span class="n">NoSignedWrap</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NSWRegion</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getSignedRange</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span><span class="w"></span>
<span class="w">        </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// (A &lt;opcode&gt; C) --&gt; (A &lt;opcode&gt; C)&lt;nuw&gt; if the op doesn&#39;t unsign overflow.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SignOrUnsignWrap</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">NUWRegion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConstantRange</span><span class="o">::</span><span class="n">makeGuaranteedNoWrapRegion</span><span class="p">(</span><span class="w"></span>
<span class="w">          </span><span class="n">Opcode</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">OBO</span><span class="o">::</span><span class="n">NoUnsignedWrap</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">NUWRegion</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SE</span><span class="o">-&gt;</span><span class="n">getUnsignedRange</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span><span class="w"></span>
<span class="w">        </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// &lt;0,+,nonnegative&gt;&lt;nw&gt; is also nuw</span>
<span class="w">  </span><span class="c1">// TODO: Add corresponding nsw case</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scAddRecExpr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNW</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Ops</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">isZero</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">IsKnownNonNegative</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="w"></span>
<span class="w">    </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// both (udiv X, Y) * Y and Y * (udiv X, Y) are always NUW</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">scMulExpr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">Ops</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">UDiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVUDivExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UDiv</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ops</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">UDiv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVUDivExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ops</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">UDiv</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"></span>
<span class="w">        </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Flags</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">howManyLessThans</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVPredicate</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Predicates</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">IV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">PredicatedIV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">canAssumeNoSelfWrap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">AR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Can we prove this loop *must* be UB if overflow of IV occurs?</span>
<span class="w">    </span><span class="c1">// Reasoning goes as follows:</span>
<span class="w">    </span><span class="c1">// * Suppose the IV did self wrap.</span>
<span class="w">    </span><span class="c1">// * If Stride evenly divides the iteration space, then once wrap</span>
<span class="w">    </span><span class="c1">//   occurs, the loop must revisit the same values.</span>
<span class="w">    </span><span class="c1">// * We know that RHS is invariant, and that none of those values</span>
<span class="w">    </span><span class="c1">//   caused this exit to be taken previously.  Thus, this exit is</span>
<span class="w">    </span><span class="c1">//   dynamically dead.</span>
<span class="w">    </span><span class="c1">// * If this is the sole exit, then a dead exit implies the loop</span>
<span class="w">    </span><span class="c1">//   must be infinite if there are no abnormal exits.</span>
<span class="w">    </span><span class="c1">// * If the loop were infinite, then it must either not be mustprogress</span>
<span class="w">    </span><span class="c1">//   or have side effects. Otherwise, it must be UB.</span>
<span class="w">    </span><span class="c1">// * It can&#39;t (by assumption), be UB so we have contradicted our</span>
<span class="w">    </span><span class="c1">//   premise and can conclude the IV did not in fact self-wrap.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">StrideC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getStepRecurrence</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">StrideC</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">StrideC</span><span class="o">-&gt;</span><span class="n">getAPInt</span><span class="p">().</span><span class="n">isPowerOf2</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">loopHasNoAbnormalExits</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">loopIsFiniteByAssumption</span><span class="p">(</span><span class="n">L</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">};</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IV</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">ZExt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVZeroExtendExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">AR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ZExt</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">());</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">isAffine</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getNoWrapFlags</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">hasFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNW</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">canAssumeNoSelfWrap</span><span class="p">(</span><span class="n">AR</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">setFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">,</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNW</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">Operands</span><span class="p">{</span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">operands</span><span class="p">()};</span><span class="w"></span>
<span class="w">          </span><span class="n">Flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StrengthenNoWrapFlags</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">scAddRecExpr</span><span class="p">,</span><span class="w"> </span><span class="n">Operands</span><span class="p">,</span><span class="w"> </span><span class="n">Flags</span><span class="p">);</span><span class="w"></span>

<span class="w">          </span><span class="n">setNoWrapFlags</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">AR</span><span class="p">),</span><span class="w"> </span><span class="n">Flags</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">hasNoUnsignedWrap</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Emulate what getZeroExtendExpr would have done during construction</span>
<span class="w">          </span><span class="c1">// if we&#39;d been able to infer the fact just above at that time.</span>
<span class="w">          </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getStepRecurrence</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">          </span><span class="n">Type</span><span class="w"> </span><span class="o">*</span><span class="n">Ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ZExt</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">();</span><span class="w"></span>
<span class="w">          </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAddRecExpr</span><span class="p">(</span><span class="w"></span>
<span class="w">              </span><span class="n">getExtendAddRecStart</span><span class="o">&lt;</span><span class="n">SCEVZeroExtendExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AR</span><span class="p">,</span><span class="w"> </span><span class="n">Ty</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">              </span><span class="n">getZeroExtendExpr</span><span class="p">(</span><span class="n">Step</span><span class="p">,</span><span class="w"> </span><span class="n">Ty</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">AR</span><span class="o">-&gt;</span><span class="n">getNoWrapFlags</span><span class="p">());</span><span class="w"></span>
<span class="w">          </span><span class="n">IV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">S</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IV</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Try to make this an AddRec using runtime tests, in the first X</span>
<span class="w">    </span><span class="c1">// iterations of this loop, where X is the SCEV expression found by the</span>
<span class="w">    </span><span class="c1">// algorithm below.</span>
<span class="w">    </span><span class="n">IV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertSCEVToAddRecWithPredicates</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Predicates</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">PredicatedIV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Avoid weird loops</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IV</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">isAffine</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// A precondition of this method is that the condition being analyzed</span>
<span class="w">  </span><span class="c1">// reaches an exiting branch which dominates the latch.  Given that, we can</span>
<span class="w">  </span><span class="c1">// assume that an increment which violates the nowrap specification and</span>
<span class="w">  </span><span class="c1">// produces poison must cause undefined behavior when the resulting poison</span>
<span class="w">  </span><span class="c1">// value is branched upon and thus we can conclude that the backedge is</span>
<span class="w">  </span><span class="c1">// taken no more often than would be required to produce that poison value.</span>
<span class="w">  </span><span class="c1">// Note that a well defined loop can exit on the iteration which violates</span>
<span class="w">  </span><span class="c1">// the nowrap specification if there is another exit (either explicit or</span>
<span class="w">  </span><span class="c1">// implicit/exceptional) which causes the loop to execute before the</span>
<span class="w">  </span><span class="c1">// exiting instruction we&#39;re analyzing would trigger UB.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">WrapType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNSW</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SCEV</span><span class="o">::</span><span class="n">FlagNUW</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">NoWrap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getNoWrapFlags</span><span class="p">(</span><span class="n">WrapType</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">Cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULT</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getStepRecurrence</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">PositiveStride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isKnownPositive</span><span class="p">(</span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Avoid negative or zero stride values.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">PositiveStride</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// We can compute the correct backedge taken count for loops with unknown</span>
<span class="w">    </span><span class="c1">// strides if we can prove that the loop is not an infinite loop with side</span>
<span class="w">    </span><span class="c1">// effects. Here&#39;s the loop structure we are trying to handle -</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// i = start</span>
<span class="w">    </span><span class="c1">// do {</span>
<span class="w">    </span><span class="c1">//   A[i] = i;</span>
<span class="w">    </span><span class="c1">//   i += s;</span>
<span class="w">    </span><span class="c1">// } while (i &lt; end);</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The backedge taken count for such loops is evaluated as -</span>
<span class="w">    </span><span class="c1">// (max(end, start + stride) - start - 1) /u stride</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The additional preconditions that we need to check to prove correctness</span>
<span class="w">    </span><span class="c1">// of the above formula is as follows -</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// a) IV is either nuw or nsw depending upon signedness (indicated by the</span>
<span class="w">    </span><span class="c1">//    NoWrap flag).</span>
<span class="w">    </span><span class="c1">// b) the loop is guaranteed to be finite (e.g. is mustprogress and has</span>
<span class="w">    </span><span class="c1">//    no side effects within the loop)</span>
<span class="w">    </span><span class="c1">// c) loop has a single static exit (with no abnormal exits)</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Precondition a) implies that if the stride is negative, this is a single</span>
<span class="w">    </span><span class="c1">// trip loop. The backedge taken count formula reduces to zero in this case.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Precondition b) and c) combine to imply that if rhs is invariant in L,</span>
<span class="w">    </span><span class="c1">// then a zero stride means the backedge can&#39;t be taken without executing</span>
<span class="w">    </span><span class="c1">// undefined behavior.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The positive stride case is the same as isKnownPositive(Stride) returning</span>
<span class="w">    </span><span class="c1">// true (original behavior of the function).</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PredicatedIV</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">NoWrap</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">loopIsFiniteByAssumption</span><span class="p">(</span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">        </span><span class="o">!</span><span class="n">loopHasNoAbnormalExits</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// This bailout is protecting the logic in computeMaxBECountForLT which</span>
<span class="w">    </span><span class="c1">// has not yet been sufficiently auditted or tested with negative strides.</span>
<span class="w">    </span><span class="c1">// We used to filter out all known-non-positive cases here, we&#39;re in the</span>
<span class="w">    </span><span class="c1">// process of being less restrictive bit by bit.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsSigned</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">isKnownNonPositive</span><span class="p">(</span><span class="n">Stride</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isKnownNonZero</span><span class="p">(</span><span class="n">Stride</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// If we have a step of zero, and RHS isn&#39;t invariant in L, we don&#39;t know</span>
<span class="w">      </span><span class="c1">// if it might eventually be greater than start and if so, on which</span>
<span class="w">      </span><span class="c1">// iteration.  We can&#39;t even produce a useful upper bound.</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>

<span class="w">      </span><span class="c1">// We allow a potentially zero stride, but we need to divide by stride</span>
<span class="w">      </span><span class="c1">// below.  Since the loop can&#39;t be infinite and this check must control</span>
<span class="w">      </span><span class="c1">// the sole exit, we can infer the exit must be taken on the first</span>
<span class="w">      </span><span class="c1">// iteration (e.g. backedge count = 0) if the stride is zero.  Given that,</span>
<span class="w">      </span><span class="c1">// we know the numerator in the divides below must be zero, so we can</span>
<span class="w">      </span><span class="c1">// pick an arbitrary non-zero value for the denominator (e.g. stride)</span>
<span class="w">      </span><span class="c1">// and produce the right result.</span>
<span class="w">      </span><span class="c1">// FIXME: Handle the case where Stride is poison?</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">wouldZeroStrideBeUB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Proof by contradiction.  Suppose the stride were zero.  If we can</span>
<span class="w">        </span><span class="c1">// prove that the backedge *is* taken on the first iteration, then since</span>
<span class="w">        </span><span class="c1">// we know this condition controls the sole exit, we must have an</span>
<span class="w">        </span><span class="c1">// infinite loop.  We can&#39;t have a (well defined) infinite loop per</span>
<span class="w">        </span><span class="c1">// check just above.</span>
<span class="w">        </span><span class="c1">// Note: The (Start - Stride) term is used to get the start&#39; term from</span>
<span class="w">        </span><span class="c1">// (start&#39; + stride,+,stride). Remember that we only care about the</span>
<span class="w">        </span><span class="c1">// result of this expression when stride == 0 at runtime.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">StartIfZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getStart</span><span class="p">(),</span><span class="w"> </span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Cond</span><span class="p">,</span><span class="w"> </span><span class="n">StartIfZero</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="p">};</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">wouldZeroStrideBeUB</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getUMaxExpr</span><span class="p">(</span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">getOne</span><span class="p">(</span><span class="n">Stride</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()));</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Stride</span><span class="o">-&gt;</span><span class="n">isOne</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">NoWrap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">isUBOnWrap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// From no-self-wrap, we need to then prove no-(un)signed-wrap.  This</span>
<span class="w">      </span><span class="c1">// follows trivially from the fact that every (un)signed-wrapped, but</span>
<span class="w">      </span><span class="c1">// not self-wrapped value must be LT than the last value before</span>
<span class="w">      </span><span class="c1">// (un)signed wrap.  Since we know that last value didn&#39;t exit, nor</span>
<span class="w">      </span><span class="c1">// will any smaller one.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">canAssumeNoSelfWrap</span><span class="p">(</span><span class="n">IV</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Avoid proven overflow cases: this will ensure that the backedge taken</span>
<span class="w">    </span><span class="c1">// count will not generate any unsigned overflow. Relaxed no-overflow</span>
<span class="w">    </span><span class="c1">// conditions exploit NoWrapFlags, allowing to optimize in presence of</span>
<span class="w">    </span><span class="c1">// undefined behaviors like the case of C language.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">canIVOverflowOnLT</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">isUBOnWrap</span><span class="p">())</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// On all paths just preceeding, we established the following invariant:</span>
<span class="w">  </span><span class="c1">//   IV can be assumed not to overflow up to and including the exiting</span>
<span class="w">  </span><span class="c1">//   iteration.  We proved this in one of two ways:</span>
<span class="w">  </span><span class="c1">//   1) We can show overflow doesn&#39;t occur before the exiting iteration</span>
<span class="w">  </span><span class="c1">//      1a) canIVOverflowOnLT, and b) step of one</span>
<span class="w">  </span><span class="c1">//   2) We can show that if overflow occurs, the loop must execute UB</span>
<span class="w">  </span><span class="c1">//      before any possible exit.</span>
<span class="w">  </span><span class="c1">// Note that we have not yet proved RHS invariant (in general).</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getStart</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Preserve pointer-typed Start/RHS to pass to isLoopEntryGuardedByCond.</span>
<span class="w">  </span><span class="c1">// If we convert to integers, isLoopEntryGuardedByCond will miss some cases.</span>
<span class="w">  </span><span class="c1">// Use integer-typed versions for actual computation; we can&#39;t subtract</span>
<span class="w">  </span><span class="c1">// pointers in general.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">OrigStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Start</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">OrigRHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RHS</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Start</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isPointerTy</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getLosslessPtrToIntExpr</span><span class="p">(</span><span class="n">Start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Start</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">Start</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">RHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isPointerTy</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">RHS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getLosslessPtrToIntExpr</span><span class="p">(</span><span class="n">RHS</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RHS</span><span class="p">))</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">RHS</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// When the RHS is not invariant, we do not know the end bound of the loop and</span>
<span class="w">  </span><span class="c1">// cannot calculate the ExactBECount needed by ExitLimit. However, we can</span>
<span class="w">  </span><span class="c1">// calculate the MaxBECount, given the start, stride and max value for the end</span>
<span class="w">  </span><span class="c1">// bound of the loop (RHS), and the fact that IV does not overflow (which is</span>
<span class="w">  </span><span class="c1">// checked above).</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeMaxBECountForLT</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">LHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">getCouldNotCompute</span><span class="p">()</span><span class="w"> </span><span class="cm">/* ExactNotTaken */</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="nb">false</span><span class="w"> </span><span class="cm">/*MaxOrZero*/</span><span class="p">,</span><span class="w"> </span><span class="n">Predicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// We use the expression (max(End,Start)-Start)/Stride to describe the</span>
<span class="w">  </span><span class="c1">// backedge count, as if the backedge is taken at least once max(End,Start)</span>
<span class="w">  </span><span class="c1">// is End and so the result is as above, and if not max(End,Start) is Start</span>
<span class="w">  </span><span class="c1">// so we get a backedge count of zero.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">OrigStartMinusStride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">OrigStart</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">isAvailableAtLoopEntry</span><span class="p">(</span><span class="n">OrigStartMinusStride</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Must be!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">isAvailableAtLoopEntry</span><span class="p">(</span><span class="n">OrigStart</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Must be!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">isAvailableAtLoopEntry</span><span class="p">(</span><span class="n">OrigRHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;Must be!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Can we prove (max(RHS,Start) &gt; Start - Stride?</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Cond</span><span class="p">,</span><span class="w"> </span><span class="n">OrigStartMinusStride</span><span class="p">,</span><span class="w"> </span><span class="n">OrigStart</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Cond</span><span class="p">,</span><span class="w"> </span><span class="n">OrigStartMinusStride</span><span class="p">,</span><span class="w"> </span><span class="n">OrigRHS</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// In this case, we can use a refined formula for computing backedge taken</span>
<span class="w">    </span><span class="c1">// count.  The general formula remains:</span>
<span class="w">    </span><span class="c1">//   &quot;End-Start /uceiling Stride&quot; where &quot;End = max(RHS,Start)&quot;</span>
<span class="w">    </span><span class="c1">// We want to use the alternate formula:</span>
<span class="w">    </span><span class="c1">//   &quot;((End - 1) - (Start - Stride)) /u Stride&quot;</span>
<span class="w">    </span><span class="c1">// Let&#39;s do a quick case analysis to show these are equivalent under</span>
<span class="w">    </span><span class="c1">// our precondition that max(RHS,Start) &gt; Start - Stride.</span>
<span class="w">    </span><span class="c1">// * For RHS &lt;= Start, the backedge-taken count must be zero.</span>
<span class="w">    </span><span class="c1">//   &quot;((End - 1) - (Start - Stride)) /u Stride&quot; reduces to</span>
<span class="w">    </span><span class="c1">//   &quot;((Start - 1) - (Start - Stride)) /u Stride&quot; which simplies to</span>
<span class="w">    </span><span class="c1">//   &quot;Stride - 1 /u Stride&quot; which is indeed zero for all non-zero values</span>
<span class="w">    </span><span class="c1">//     of Stride.  For 0 stride, we&#39;ve use umin(1,Stride) above, reducing</span>
<span class="w">    </span><span class="c1">//     this to the stride of 1 case.</span>
<span class="w">    </span><span class="c1">// * For RHS &gt;= Start, the backedge count must be &quot;RHS-Start /uceil Stride&quot;.</span>
<span class="w">    </span><span class="c1">//   &quot;((End - 1) - (Start - Stride)) /u Stride&quot; reduces to</span>
<span class="w">    </span><span class="c1">//   &quot;((RHS - 1) - (Start - Stride)) /u Stride&quot; reassociates to</span>
<span class="w">    </span><span class="c1">//   &quot;((RHS - (Start - Stride) - 1) /u Stride&quot;.</span>
<span class="w">    </span><span class="c1">//   Our preconditions trivially imply no overflow in that form.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MinusOne</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMinusOne</span><span class="p">(</span><span class="n">Stride</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Numerator</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">        </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">MinusOne</span><span class="p">),</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getUDivExpr</span><span class="p">(</span><span class="n">Numerator</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECountIfBackedgeTaken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">BECount</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">canProveRHSGreaterThanEqualStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">CondGE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGE</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGE</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">CondGE</span><span class="p">,</span><span class="w"> </span><span class="n">OrigRHS</span><span class="p">,</span><span class="w"> </span><span class="n">OrigStart</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>

<span class="w">      </span><span class="c1">// (RHS &gt; Start - 1) implies RHS &gt;= Start.</span>
<span class="w">      </span><span class="c1">// * &quot;RHS &gt;= Start&quot; is trivially equivalent to &quot;RHS &gt; Start - 1&quot; if</span>
<span class="w">      </span><span class="c1">//   &quot;Start - 1&quot; doesn&#39;t overflow.</span>
<span class="w">      </span><span class="c1">// * For signed comparison, if Start - 1 does overflow, it&#39;s equal</span>
<span class="w">      </span><span class="c1">//   to INT_MAX, and &quot;RHS &gt;s INT_MAX&quot; is trivially false.</span>
<span class="w">      </span><span class="c1">// * For unsigned comparison, if Start - 1 does overflow, it&#39;s equal</span>
<span class="w">      </span><span class="c1">//   to UINT_MAX, and &quot;RHS &gt;u UINT_MAX&quot; is trivially false.</span>
<span class="w">      </span><span class="c1">//</span>
<span class="w">      </span><span class="c1">// FIXME: Should isLoopEntryGuardedByCond do this for us?</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">CondGT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SGT</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_UGT</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">StartMinusOne</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">OrigStart</span><span class="p">,</span><span class="w"> </span><span class="n">getMinusOne</span><span class="p">(</span><span class="n">OrigStart</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()));</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">CondGT</span><span class="p">,</span><span class="w"> </span><span class="n">OrigRHS</span><span class="p">,</span><span class="w"> </span><span class="n">StartMinusOne</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// If we know that RHS &gt;= Start in the context of loop, then we know that</span>
<span class="w">    </span><span class="c1">// max(RHS, Start) = RHS at this point.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">End</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">canProveRHSGreaterThanEqualStart</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RHS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// If RHS &lt; Start, the backedge will be taken zero times.  So in</span>
<span class="w">      </span><span class="c1">// general, we can write the backedge-taken count as:</span>
<span class="w">      </span><span class="c1">//</span>
<span class="w">      </span><span class="c1">//     RHS &gt;= Start ? ceil(RHS - Start) / Stride : 0</span>
<span class="w">      </span><span class="c1">//</span>
<span class="w">      </span><span class="c1">// We convert it to the following to make it more convenient for SCEV:</span>
<span class="w">      </span><span class="c1">//</span>
<span class="w">      </span><span class="c1">//     ceil(max(RHS, Start) - Start) / Stride</span>
<span class="w">      </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">getSMaxExpr</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">getUMaxExpr</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">);</span><span class="w"></span>

<span class="w">      </span><span class="c1">// See what would happen if we assume the backedge is taken. This is</span>
<span class="w">      </span><span class="c1">// used to compute MaxBECount.</span>
<span class="w">      </span><span class="n">BECountIfBackedgeTaken</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">getUDivCeilSCEV</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">),</span><span class="w"> </span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// At this point, we know:</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// 1. If IsSigned, Start &lt;=s End; otherwise, Start &lt;=u End</span>
<span class="w">    </span><span class="c1">// 2. The index variable doesn&#39;t overflow.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Therefore, we know N exists such that</span>
<span class="w">    </span><span class="c1">// (Start + Stride * N) &gt;= End, and computing &quot;(Start + Stride * N)&quot;</span>
<span class="w">    </span><span class="c1">// doesn&#39;t overflow.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Using this information, try to prove whether the addition in</span>
<span class="w">    </span><span class="c1">// &quot;(Start - End) + (Stride - 1)&quot; has unsigned overflow.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">One</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOne</span><span class="p">(</span><span class="n">Stride</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">MayAddOverflow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">StrideC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Stride</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">StrideC</span><span class="o">-&gt;</span><span class="n">getAPInt</span><span class="p">().</span><span class="n">isPowerOf2</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="c1">// Suppose Stride is a power of two, and Start/End are unsigned</span>
<span class="w">          </span><span class="c1">// integers.  Let UMAX be the largest representable unsigned</span>
<span class="w">          </span><span class="c1">// integer.</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// By the preconditions of this function, we know</span>
<span class="w">          </span><span class="c1">// &quot;(Start + Stride * N) &gt;= End&quot;, and this doesn&#39;t overflow.</span>
<span class="w">          </span><span class="c1">// As a formula:</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   End &lt;= (Start + Stride * N) &lt;= UMAX</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// Subtracting Start from all the terms:</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   End - Start &lt;= Stride * N &lt;= UMAX - Start</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// Since Start is unsigned, UMAX - Start &lt;= UMAX.  Therefore:</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   End - Start &lt;= Stride * N &lt;= UMAX</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// Stride * N is a multiple of Stride. Therefore,</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   End - Start &lt;= Stride * N &lt;= UMAX - (UMAX mod Stride)</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// Since Stride is a power of two, UMAX + 1 is divisible by Stride.</span>
<span class="w">          </span><span class="c1">// Therefore, UMAX mod Stride == Stride - 1.  So we can write:</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   End - Start &lt;= Stride * N &lt;= UMAX - Stride - 1</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// Dropping the middle term:</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   End - Start &lt;= UMAX - Stride - 1</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// Adding Stride - 1 to both sides:</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">//   (End - Start) + (Stride - 1) &lt;= UMAX</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// In other words, the addition doesn&#39;t have unsigned overflow.</span>
<span class="w">          </span><span class="c1">//</span>
<span class="w">          </span><span class="c1">// A similar proof works if we treat Start/End as signed values.</span>
<span class="w">          </span><span class="c1">// Just rewrite steps before &quot;End - Start &lt;= Stride * N &lt;= UMAX&quot; to</span>
<span class="w">          </span><span class="c1">// use signed max instead of unsigned max. Note that we&#39;re trying</span>
<span class="w">          </span><span class="c1">// to prove a lack of unsigned overflow in either case.</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Stride</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">Start</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">One</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// If Start is equal to Stride, (End - Start) + (Stride - 1) == End - 1.</span>
<span class="w">        </span><span class="c1">// If !IsSigned, 0 &lt;u Stride == Start &lt;=u End; so 0 &lt;u End - 1 &lt;u End.</span>
<span class="w">        </span><span class="c1">// If IsSigned, 0 &lt;s Stride == Start &lt;=s End; so 0 &lt;s End - 1 &lt;s End.</span>
<span class="w">        </span><span class="c1">//</span>
<span class="w">        </span><span class="c1">// If Start is equal to Stride - 1, (End - Start) + Stride - 1 == End.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}();</span><span class="w"></span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">MayAddOverflow</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="c1">// floor((D + (S - 1)) / S)</span>
<span class="w">      </span><span class="c1">// We prefer this formulation if it&#39;s legal because it&#39;s fewer operations.</span>
<span class="w">      </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">          </span><span class="n">getUDivExpr</span><span class="p">(</span><span class="n">getAddExpr</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">One</span><span class="p">)),</span><span class="w"> </span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getUDivCeilSCEV</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">MaxOrZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BECount</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BECountIfBackedgeTaken</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">             </span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECountIfBackedgeTaken</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If we know exactly how many times the backedge will be taken if it&#39;s</span>
<span class="w">    </span><span class="c1">// taken at least once, then the backedge count will either be that or</span>
<span class="w">    </span><span class="c1">// zero.</span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BECountIfBackedgeTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxOrZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeMaxBECountForLT</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">LHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaxBECount</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConstant</span><span class="p">(</span><span class="n">getUnsignedRangeMax</span><span class="p">(</span><span class="n">BECount</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">BECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxOrZero</span><span class="p">,</span><span class="w"> </span><span class="n">Predicates</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="n">ScalarEvolution</span><span class="o">::</span><span class="n">ExitLimit</span><span class="w"> </span><span class="n">MustExitScalarEvolution</span><span class="o">::</span><span class="n">howManyLessThans</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="o">*</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ControlsExit</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">SmallPtrSet</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">SCEVPredicate</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Predicates</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEVAddRecExpr</span><span class="w"> </span><span class="o">*</span><span class="n">IV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">SCEVAddRecExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IV</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">AllowPredicates</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Try to make this an AddRec using runtime tests, in the first X</span>
<span class="w">    </span><span class="c1">// iterations of this loop, where X is the SCEV expression found by the</span>
<span class="w">    </span><span class="c1">// algorithm below.</span>
<span class="w">    </span><span class="n">IV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">convertSCEVToAddRecWithPredicates</span><span class="p">(</span><span class="n">LHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Predicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Avoid weird loops</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IV</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getLoop</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">isAffine</span><span class="p">())</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">NoWrap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ControlsExit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// changed this to assume no wrap for inc</span>
<span class="w">  </span><span class="c1">//              IV-&gt;getNoWrapFlags(IsSigned ? SCEV::FlagNSW : SCEV::FlagNUW);</span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getStepRecurrence</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">PositiveStride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isKnownPositive</span><span class="p">(</span><span class="n">Stride</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Avoid negative or zero stride values.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">PositiveStride</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// We can compute the correct backedge taken count for loops with unknown</span>
<span class="w">    </span><span class="c1">// strides if we can prove that the loop is not an infinite loop with side</span>
<span class="w">    </span><span class="c1">// effects. Here&#39;s the loop structure we are trying to handle -</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// i = start</span>
<span class="w">    </span><span class="c1">// do {</span>
<span class="w">    </span><span class="c1">//   A[i] = i;</span>
<span class="w">    </span><span class="c1">//   i += s;</span>
<span class="w">    </span><span class="c1">// } while (i &lt; end);</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The backedge taken count for such loops is evaluated as -</span>
<span class="w">    </span><span class="c1">// (max(end, start + stride) - start - 1) /u stride</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The additional preconditions that we need to check to prove correctness</span>
<span class="w">    </span><span class="c1">// of the above formula is as follows -</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// a) IV is either nuw or nsw depending upon signedness (indicated by the</span>
<span class="w">    </span><span class="c1">//    NoWrap flag).</span>
<span class="w">    </span><span class="c1">// b) loop is single exit with no side effects. // dont need this</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Precondition a) implies that if the stride is negative, this is a single</span>
<span class="w">    </span><span class="c1">// trip loop. The backedge taken count formula reduces to zero in this case.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Precondition b) implies that the unknown stride cannot be zero otherwise</span>
<span class="w">    </span><span class="c1">// we have UB.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The positive stride case is the same as isKnownPositive(Stride) returning</span>
<span class="w">    </span><span class="c1">// true (original behavior of the function).</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// We want to make sure that the stride is truly unknown as there are edge</span>
<span class="w">    </span><span class="c1">// cases where ScalarEvolution propagates no wrap flags to the</span>
<span class="w">    </span><span class="c1">// post-increment/decrement IV even though the increment/decrement operation</span>
<span class="w">    </span><span class="c1">// itself is wrapping. The computed backedge taken count may be wrong in</span>
<span class="w">    </span><span class="c1">// such cases. This is prevented by checking that the stride is not known to</span>
<span class="w">    </span><span class="c1">// be either positive or non-positive. For example, no wrap flags are</span>
<span class="w">    </span><span class="c1">// propagated to the post-increment IV of this loop with a trip count of 2 -</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// unsigned char i;</span>
<span class="w">    </span><span class="c1">// for(i=127; i&lt;128; i+=129)</span>
<span class="w">    </span><span class="c1">//   A[i] = i;</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">NoWrap</span><span class="p">)</span><span class="w"> </span><span class="c1">// THIS LINE CHANGED</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Stride</span><span class="o">-&gt;</span><span class="n">isOne</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">             </span><span class="n">doesIVOverflowOnLT</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">,</span><span class="w"> </span><span class="n">NoWrap</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Avoid proven overflow cases: this will ensure that the backedge taken</span>
<span class="w">    </span><span class="c1">// count will not generate any unsigned overflow. Relaxed no-overflow</span>
<span class="w">    </span><span class="c1">// conditions exploit NoWrapFlags, allowing to optimize in presence of</span>
<span class="w">    </span><span class="c1">// undefined behaviors like the case of C language.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getCouldNotCompute</span><span class="p">();</span><span class="w"></span>

<span class="w">  </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">Predicate</span><span class="w"> </span><span class="n">Cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_SLT</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ICmpInst</span><span class="o">::</span><span class="n">ICMP_ULT</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">Start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IV</span><span class="o">-&gt;</span><span class="n">getStart</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RHS</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// When the RHS is not invariant, we do not know the end bound of the loop and</span>
<span class="w">  </span><span class="c1">// cannot calculate the ExactBECount needed by ExitLimit. However, we can</span>
<span class="w">  </span><span class="c1">// calculate the MaxBECount, given the start, stride and max value for the end</span>
<span class="w">  </span><span class="c1">// bound of the loop (RHS), and the fact that IV does not overflow (which is</span>
<span class="w">  </span><span class="c1">// checked above).</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isLoopInvariant</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeMaxBECountForLT</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">LHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">getCouldNotCompute</span><span class="p">()</span><span class="w"> </span><span class="cm">/* ExactNotTaken */</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"></span>
<span class="w">                     </span><span class="nb">false</span><span class="w"> </span><span class="cm">/*MaxOrZero*/</span><span class="p">,</span><span class="w"> </span><span class="n">Predicates</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If the backedge is taken at least once, then it will be taken</span>
<span class="w">  </span><span class="c1">// (End-Start)/Stride times (rounded up to a multiple of Stride), where Start</span>
<span class="w">  </span><span class="c1">// is the LHS value of the less-than comparison the first time it is evaluated</span>
<span class="w">  </span><span class="c1">// and End is the RHS.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECountIfBackedgeTaken</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">      </span><span class="n">computeBECount</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">),</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="c1">// If the loop entry is guarded by the result of the backedge test of the</span>
<span class="w">  </span><span class="c1">// first loop iteration, then we know the backedge will be taken at least</span>
<span class="w">  </span><span class="c1">// once and so the backedge taken count is as above. If not then we use the</span>
<span class="w">  </span><span class="c1">// expression (max(End,Start)-Start)/Stride to describe the backedge count,</span>
<span class="w">  </span><span class="c1">// as if the backedge is taken at least once max(End,Start) is End and so the</span>
<span class="w">  </span><span class="c1">// result is as above, and if not max(End,Start) is Start so we get a backedge</span>
<span class="w">  </span><span class="c1">// count of zero.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">BECount</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isLoopEntryGuardedByCond</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">Cond</span><span class="p">,</span><span class="w"> </span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">),</span><span class="w"> </span><span class="n">RHS</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BECountIfBackedgeTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">End</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IsSigned</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">getSMaxExpr</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">getUMaxExpr</span><span class="p">(</span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">BECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeBECount</span><span class="p">(</span><span class="n">getMinusSCEV</span><span class="p">(</span><span class="n">End</span><span class="p">,</span><span class="w"> </span><span class="n">Start</span><span class="p">),</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">SCEV</span><span class="w"> </span><span class="o">*</span><span class="n">MaxBECount</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">MaxOrZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BECount</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVConstant</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECountIfBackedgeTaken</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// If we know exactly how many times the backedge will be taken if it&#39;s</span>
<span class="w">    </span><span class="c1">// taken at least once, then the backedge count will either be that or</span>
<span class="w">    </span><span class="c1">// zero.</span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BECountIfBackedgeTaken</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxOrZero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">computeMaxBECountForLT</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Stride</span><span class="p">,</span><span class="w"> </span><span class="n">RHS</span><span class="p">,</span><span class="w"> </span><span class="n">getTypeSizeInBits</span><span class="p">(</span><span class="n">LHS</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()),</span><span class="w"> </span><span class="n">IsSigned</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MaxBECount</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"></span>
<span class="w">      </span><span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">SCEVCouldNotCompute</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BECount</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="n">MaxBECount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConstant</span><span class="p">(</span><span class="n">getUnsignedRangeMax</span><span class="p">(</span><span class="n">BECount</span><span class="p">));</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ExitLimit</span><span class="p">(</span><span class="n">BECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxBECount</span><span class="p">,</span><span class="w"> </span><span class="n">MaxOrZero</span><span class="p">,</span><span class="w"> </span><span class="n">Predicates</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>


             </article>
             
            </div>
            <footer>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright Enzyme.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/EnzymeAD/enzyme_sphinx_theme">theme</a> provided by <a href="https://enzyme.mit.edu">Enzyme</a>.
      </div>
      <br>
     

</footer>

          </div>
        </div>

        <div class="enzyme-content-right" id="enzyme-content-right">
          <div class="enzyme-right-menu" id="enzyme-right-menu">
            <div class="enzyme-side-scroll" id="enzyme-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Program Listing for File MustExitScalarEvolution.cpp</a></li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  


  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
         <script src="../_static/jquery.js"></script>
         <script src="../_static/underscore.js"></script>
         <script src="../_static/doctools.js"></script>
         <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
         <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <!-- Begin Footer -->

  <footer class="site-footer" id="site-footer">
    <div class="container footer-container">
      <div class="footer-logo-wrapper">
        <a href="https://enzyme.mit.edu" class="footer-logo"></a>
      </div>

      <div class="footer-links-wrapper">
        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="https://enzyme.mit.edu">Enzyme</a></li>
            <li><a href="https://enzyme.mit.edu/get-started">Get Started</a></li>
            <li><a href="https://enzyme.mit.edu/features">Features</a></li>
            <li><a href="https://github.com/EnzymeAD/enzyme/blob/master/CONTRIBUTING.md">Contributing</a></li>
          </ul>
        </div>

        <div class="footer-links-col">
          <ul>
            <li class="list-title"><a href="">Resources</a></li>
            <li><a href="https://enzyme.mit.edu/tutorials">Tutorials</a></li>
            <li><a href="https://enzyme.mit.edu/docs/stable/index.html">Docs</a></li>
            <li><a href="" target="_blank">Discuss</a></li>
            <li><a href="https://github.com/EnzymeAD/enzyme/issues" target="_blank">Github Issues</a></li>
          </ul>
        </div>

        <div class="footer-links-col follow-us-col">
          <ul>
            <li class="list-title">Stay Connected</li>
            <li>
              <div id="mc_embed_signup">
                <form
                  action="https://groups.google.com/d/forum/enzyme-dev"
                  method="post"
                  id="mc-embedded-subscribe-form"
                  name="mc-embedded-subscribe-form"
                  class="email-subscribe-form validate"
                  target="_blank"
                  novalidate>
                  <div id="mc_embed_signup_scroll" class="email-subscribe-form-fields-wrapper">
                    <div class="mc-field-group">
                      <label for="mce-EMAIL" style="display:none;">Email Address</label>
                      <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Email Address">
                    </div>

                    <div id="mce-responses" class="clear">
                      <div class="response" id="mce-error-response" style="display:none"></div>
                      <div class="response" id="mce-success-response" style="display:none"></div>
                    </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->

                    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_75419c71fe0a935e53dfa4a3f_91d0dccd39" tabindex="-1" value=""></div>

                    <div class="clear">
                      <input type="submit" value="" name="subscribe" id="mc-embedded-subscribe" class="button email-subscribe-button">
                    </div>
                  </div>
                </form>
              </div>

            </li>
          </ul>
        </div>
      </div>
    </div>
  </footer>

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://enzyme.mit.edu" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://enzyme.mit.edu/get-started">Get Started</a>
          </li>

          <li>
            <a href="">Ecosystem</a>
          </li>

          <li>
            <a href="">Mobile</a>
          </li>

          <li>
            <a href="">PyTorch Hub</a>
          </li>

          <li>
            <a href="">Blog</a>
          </li>

          <li>
            <a href="https://enzyme.mit.edu/tutorials">Tutorials</a>
          </li>

          <li class="resources-mobile-menu-title">
            Docs
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://enzyme.mit.edu/docs/stable/index.html">PyTorch</a>
            </li>

            <li>
              <a href="">torchaudio</a>
            </li>

            <li>
              <a href="">torchtext</a>
            </li>

            <li>
              <a href="">torchvision</a>
            </li>

            <li>
              <a href="">TorchElastic</a>
            </li>

            <li>
              <a href="">TorchServe</a>
            </li>

            <li>
              <a href="">PyTorch on XLA Devices</a>
            </li>
          </ul>

          <li class="resources-mobile-menu-title">
            Resources
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="">Developer Resources</a>
            </li>

            <li>
              <a href="https://enzyme.mit.edu/features">About</a>
            </li>

            <li>
              <a href="">Models (Beta)</a>
            </li>

            <li>
              <a href="">Community</a>
            </li>

            <li>
              <a href="">Forums</a>
            </li>
          </ul>

          <li>
            <a href="https://github.com/EnzymeAD/enzyme">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      enzymeAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.enzyme-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>